"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lingui+message-utils@5.3.1";
exports.ids = ["vendor-chunks/@lingui+message-utils@5.3.1"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@lingui+message-utils@5.3.1/node_modules/@lingui/message-utils/dist/compileMessage.mjs":
/*!***********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@lingui+message-utils@5.3.1/node_modules/@lingui/message-utils/dist/compileMessage.mjs ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compileMessage: () => (/* binding */ compileMessage),\n/* harmony export */   compileMessageOrThrow: () => (/* binding */ compileMessageOrThrow)\n/* harmony export */ });\n/* harmony import */ var _messageformat_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @messageformat/parser */ \"(ssr)/../../node_modules/.pnpm/@messageformat+parser@5.1.1/node_modules/@messageformat/parser/lib/parser.js\");\n\n\n/**\n * Parent class for errors.\n *\n * @remarks\n * Errors with `type: \"warning\"` do not necessarily indicate that the parser\n * encountered an error. In addition to a human-friendly `message`, may also\n * includes the `token` at which the error was encountered.\n *\n * @public\n */\nclass DateFormatError extends Error {\n    /** @internal */\n    constructor(msg, token, type) {\n        super(msg);\n        this.token = token;\n        this.type = type || 'error';\n    }\n}\nconst alpha = (width) => width < 4 ? 'short' : width === 4 ? 'long' : 'narrow';\nconst numeric = (width) => (width % 2 === 0 ? '2-digit' : 'numeric');\nfunction yearOptions(token, onError) {\n    switch (token.char) {\n        case 'y':\n            return { year: numeric(token.width) };\n        case 'r':\n            return { calendar: 'gregory', year: 'numeric' };\n        case 'u':\n        case 'U':\n        case 'Y':\n        default:\n            onError(`${token.desc} is not supported; falling back to year:numeric`, DateFormatError.WARNING);\n            return { year: 'numeric' };\n    }\n}\nfunction monthStyle(token, onError) {\n    switch (token.width) {\n        case 1:\n            return 'numeric';\n        case 2:\n            return '2-digit';\n        case 3:\n            return 'short';\n        case 4:\n            return 'long';\n        case 5:\n            return 'narrow';\n        default:\n            onError(`${token.desc} is not supported with width ${token.width}`);\n            return undefined;\n    }\n}\nfunction dayStyle(token, onError) {\n    const { char, desc, width } = token;\n    if (char === 'd') {\n        return numeric(width);\n    }\n    else {\n        onError(`${desc} is not supported`);\n        return undefined;\n    }\n}\nfunction weekdayStyle(token, onError) {\n    const { char, desc, width } = token;\n    if ((char === 'c' || char === 'e') && width < 3) {\n        // ignoring stand-alone-ness\n        const msg = `Numeric value is not supported for ${desc}; falling back to weekday:short`;\n        onError(msg, DateFormatError.WARNING);\n    }\n    // merging narrow styles\n    return alpha(width);\n}\nfunction hourOptions(token) {\n    const hour = numeric(token.width);\n    let hourCycle;\n    switch (token.char) {\n        case 'h':\n            hourCycle = 'h12';\n            break;\n        case 'H':\n            hourCycle = 'h23';\n            break;\n        case 'k':\n            hourCycle = 'h24';\n            break;\n        case 'K':\n            hourCycle = 'h11';\n            break;\n    }\n    return hourCycle ? { hour, hourCycle } : { hour };\n}\nfunction timeZoneNameStyle(token, onError) {\n    // so much fallback behaviour here\n    const { char, desc, width } = token;\n    switch (char) {\n        case 'v':\n        case 'z':\n            return width === 4 ? 'long' : 'short';\n        case 'V':\n            if (width === 4)\n                return 'long';\n            onError(`${desc} is not supported with width ${width}`);\n            return undefined;\n        case 'X':\n            onError(`${desc} is not supported`);\n            return undefined;\n    }\n    return 'short';\n}\nfunction compileOptions(token, onError) {\n    switch (token.field) {\n        case 'era':\n            return { era: alpha(token.width) };\n        case 'year':\n            return yearOptions(token, onError);\n        case 'month':\n            return { month: monthStyle(token, onError) };\n        case 'day':\n            return { day: dayStyle(token, onError) };\n        case 'weekday':\n            return { weekday: weekdayStyle(token, onError) };\n        case 'period':\n            return undefined;\n        case 'hour':\n            return hourOptions(token);\n        case 'min':\n            return { minute: numeric(token.width) };\n        case 'sec':\n            return { second: numeric(token.width) };\n        case 'tz':\n            return { timeZoneName: timeZoneNameStyle(token, onError) };\n        case 'quarter':\n        case 'week':\n        case 'sec-frac':\n        case 'ms':\n            onError(`${token.desc} is not supported`);\n    }\n    return undefined;\n}\nfunction getDateFormatOptions(tokens, timeZone, onError = error => {\n    throw error;\n}) {\n    const options = {\n        timeZone\n    };\n    const fields = [];\n    for (const token of tokens) {\n        const { error, field, str } = token;\n        if (error) {\n            const dte = new DateFormatError(error.message, token);\n            dte.stack = error.stack;\n            onError(dte);\n        }\n        if (str) {\n            const msg = `Ignoring string part: ${str}`;\n            onError(new DateFormatError(msg, token, DateFormatError.WARNING));\n        }\n        if (field) {\n            if (fields.indexOf(field) === -1)\n                fields.push(field);\n            else\n                onError(new DateFormatError(`Duplicate ${field} token`, token));\n        }\n        const opt = compileOptions(token, (msg, isWarning) => onError(new DateFormatError(msg, token, isWarning)));\n        if (opt)\n            Object.assign(options, opt);\n    }\n    return options;\n}\n\nconst fields = {\n    G: { field: 'era', desc: 'Era' },\n    y: { field: 'year', desc: 'Year' },\n    Y: { field: 'year', desc: 'Year of \"Week of Year\"' },\n    u: { field: 'year', desc: 'Extended year' },\n    U: { field: 'year', desc: 'Cyclic year name' },\n    r: { field: 'year', desc: 'Related Gregorian year' },\n    Q: { field: 'quarter', desc: 'Quarter' },\n    q: { field: 'quarter', desc: 'Stand-alone quarter' },\n    M: { field: 'month', desc: 'Month in year' },\n    L: { field: 'month', desc: 'Stand-alone month in year' },\n    w: { field: 'week', desc: 'Week of year' },\n    W: { field: 'week', desc: 'Week of month' },\n    d: { field: 'day', desc: 'Day in month' },\n    D: { field: 'day', desc: 'Day of year' },\n    F: { field: 'day', desc: 'Day of week in month' },\n    g: { field: 'day', desc: 'Modified julian day' },\n    E: { field: 'weekday', desc: 'Day of week' },\n    e: { field: 'weekday', desc: 'Local day of week' },\n    c: { field: 'weekday', desc: 'Stand-alone local day of week' },\n    a: { field: 'period', desc: 'AM/PM marker' },\n    b: { field: 'period', desc: 'AM/PM/noon/midnight marker' },\n    B: { field: 'period', desc: 'Flexible day period' },\n    h: { field: 'hour', desc: 'Hour in AM/PM (1~12)' },\n    H: { field: 'hour', desc: 'Hour in day (0~23)' },\n    k: { field: 'hour', desc: 'Hour in day (1~24)' },\n    K: { field: 'hour', desc: 'Hour in AM/PM (0~11)' },\n    j: { field: 'hour', desc: 'Hour in preferred cycle' },\n    J: { field: 'hour', desc: 'Hour in preferred cycle without marker' },\n    C: { field: 'hour', desc: 'Hour in preferred cycle with flexible marker' },\n    m: { field: 'min', desc: 'Minute in hour' },\n    s: { field: 'sec', desc: 'Second in minute' },\n    S: { field: 'sec-frac', desc: 'Fractional second' },\n    A: { field: 'ms', desc: 'Milliseconds in day' },\n    z: { field: 'tz', desc: 'Time Zone: specific non-location' },\n    Z: { field: 'tz', desc: 'Time Zone' },\n    O: { field: 'tz', desc: 'Time Zone: localized' },\n    v: { field: 'tz', desc: 'Time Zone: generic non-location' },\n    V: { field: 'tz', desc: 'Time Zone: ID' },\n    X: { field: 'tz', desc: 'Time Zone: ISO8601 with Z' },\n    x: { field: 'tz', desc: 'Time Zone: ISO8601' }\n};\nconst isLetter = (char) => (char >= 'A' && char <= 'Z') || (char >= 'a' && char <= 'z');\nfunction readFieldToken(src, pos) {\n    const char = src[pos];\n    let width = 1;\n    while (src[++pos] === char)\n        ++width;\n    const field = fields[char];\n    if (!field) {\n        const msg = `The letter ${char} is not a valid field identifier`;\n        return { char, error: new Error(msg), width };\n    }\n    return { char, field: field.field, desc: field.desc, width };\n}\nfunction readQuotedToken(src, pos) {\n    let str = src[++pos];\n    let width = 2;\n    if (str === \"'\")\n        return { char: \"'\", str, width };\n    while (true) {\n        const next = src[++pos];\n        ++width;\n        if (next === undefined) {\n            const msg = `Unterminated quoted literal in pattern: ${str || src}`;\n            return { char: \"'\", error: new Error(msg), str, width };\n        }\n        else if (next === \"'\") {\n            if (src[++pos] !== \"'\")\n                return { char: \"'\", str, width };\n            else\n                ++width;\n        }\n        str += next;\n    }\n}\nfunction readToken(src, pos) {\n    const char = src[pos];\n    if (!char)\n        return null;\n    if (isLetter(char))\n        return readFieldToken(src, pos);\n    if (char === \"'\")\n        return readQuotedToken(src, pos);\n    let str = char;\n    let width = 1;\n    while (true) {\n        const next = src[++pos];\n        if (!next || isLetter(next) || next === \"'\")\n            return { char, str, width };\n        str += next;\n        width += 1;\n    }\n}\n/**\n * Parse an {@link http://userguide.icu-project.org/formatparse/datetime | ICU\n * DateFormat skeleton} string into a {@link DateToken} array.\n *\n * @remarks\n * Errors will not be thrown, but if encountered are included as the relevant\n * token's `error` value.\n *\n * @public\n * @param src - The skeleton string\n *\n * @example\n * ```js\n * import { parseDateTokens } from '@messageformat/date-skeleton'\n *\n * parseDateTokens('GrMMMdd', console.error)\n * // [\n * //   { char: 'G', field: 'era', desc: 'Era', width: 1 },\n * //   { char: 'r', field: 'year', desc: 'Related Gregorian year', width: 1 },\n * //   { char: 'M', field: 'month', desc: 'Month in year', width: 3 },\n * //   { char: 'd', field: 'day', desc: 'Day in month', width: 2 }\n * // ]\n * ```\n */\nfunction parseDateTokens(src) {\n    const tokens = [];\n    let pos = 0;\n    while (true) {\n        const token = readToken(src, pos);\n        if (!token)\n            return tokens;\n        tokens.push(token);\n        pos += token.width;\n    }\n}\n\nfunction processTokens(tokens, mapText) {\n  if (!tokens.filter((token) => token.type !== \"content\").length) {\n    return tokens.map((token) => mapText(token.value));\n  }\n  return tokens.map((token) => {\n    if (token.type === \"content\") {\n      return mapText(token.value);\n    } else if (token.type === \"octothorpe\") {\n      return \"#\";\n    } else if (token.type === \"argument\") {\n      return [token.arg];\n    } else if (token.type === \"function\") {\n      const _param = token?.param?.[0];\n      if (token.key === \"date\" && _param) {\n        const opts = compileDateExpression(_param.value.trim(), (e) => {\n          throw new Error(`Unable to compile date expression: ${e.message}`);\n        });\n        return [token.arg, token.key, opts];\n      }\n      if (_param) {\n        return [token.arg, token.key, _param.value.trim()];\n      } else {\n        return [token.arg, token.key];\n      }\n    }\n    const offset = token.pluralOffset;\n    const formatProps = {};\n    token.cases.forEach(({ key, tokens: tokens2 }) => {\n      const prop = key[0] === \"=\" ? key.slice(1) : key;\n      formatProps[prop] = processTokens(tokens2, mapText);\n    });\n    return [\n      token.arg,\n      token.type,\n      {\n        offset,\n        ...formatProps\n      }\n    ];\n  });\n}\nfunction compileDateExpression(format, onError) {\n  if (/^::/.test(format)) {\n    const tokens = parseDateTokens(format.substring(2));\n    return getDateFormatOptions(tokens, void 0, onError);\n  }\n  return format;\n}\nfunction compileMessageOrThrow(message, mapText = (v) => v) {\n  return processTokens((0,_messageformat_parser__WEBPACK_IMPORTED_MODULE_0__.parse)(message), mapText);\n}\nfunction compileMessage(message, mapText = (v) => v) {\n  try {\n    return compileMessageOrThrow(message, mapText);\n  } catch (e) {\n    console.error(`${e.message} \n\nMessage: ${message}`);\n    return [message];\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BsaW5ndWkrbWVzc2FnZS11dGlsc0A1LjMuMS9ub2RlX21vZHVsZXMvQGxpbmd1aS9tZXNzYWdlLXV0aWxzL2Rpc3QvY29tcGlsZU1lc3NhZ2UubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZLGtCQUFrQjtBQUNyRCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVksOEJBQThCLFlBQVk7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBLDBEQUEwRCxPQUFPO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtCQUFrQixJQUFJO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE1BQU0sOEJBQThCLE1BQU07QUFDakU7QUFDQTtBQUNBLHVCQUF1QixNQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDTjtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsVUFBVTtBQUMxRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0REFBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixxQkFBcUI7O0FBRXJCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRWlEIiwic291cmNlcyI6WyIvVXNlcnMvYXJ0ZW0uc3RlcGFub3YvZnJvbnRlbmQtbW9uby9ub2RlX21vZHVsZXMvLnBucG0vQGxpbmd1aSttZXNzYWdlLXV0aWxzQDUuMy4xL25vZGVfbW9kdWxlcy9AbGluZ3VpL21lc3NhZ2UtdXRpbHMvZGlzdC9jb21waWxlTWVzc2FnZS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2UgfSBmcm9tICdAbWVzc2FnZWZvcm1hdC9wYXJzZXInO1xuXG4vKipcbiAqIFBhcmVudCBjbGFzcyBmb3IgZXJyb3JzLlxuICpcbiAqIEByZW1hcmtzXG4gKiBFcnJvcnMgd2l0aCBgdHlwZTogXCJ3YXJuaW5nXCJgIGRvIG5vdCBuZWNlc3NhcmlseSBpbmRpY2F0ZSB0aGF0IHRoZSBwYXJzZXJcbiAqIGVuY291bnRlcmVkIGFuIGVycm9yLiBJbiBhZGRpdGlvbiB0byBhIGh1bWFuLWZyaWVuZGx5IGBtZXNzYWdlYCwgbWF5IGFsc29cbiAqIGluY2x1ZGVzIHRoZSBgdG9rZW5gIGF0IHdoaWNoIHRoZSBlcnJvciB3YXMgZW5jb3VudGVyZWQuXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBEYXRlRm9ybWF0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGNvbnN0cnVjdG9yKG1zZywgdG9rZW4sIHR5cGUpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8ICdlcnJvcic7XG4gICAgfVxufVxuY29uc3QgYWxwaGEgPSAod2lkdGgpID0+IHdpZHRoIDwgNCA/ICdzaG9ydCcgOiB3aWR0aCA9PT0gNCA/ICdsb25nJyA6ICduYXJyb3cnO1xuY29uc3QgbnVtZXJpYyA9ICh3aWR0aCkgPT4gKHdpZHRoICUgMiA9PT0gMCA/ICcyLWRpZ2l0JyA6ICdudW1lcmljJyk7XG5mdW5jdGlvbiB5ZWFyT3B0aW9ucyh0b2tlbiwgb25FcnJvcikge1xuICAgIHN3aXRjaCAodG9rZW4uY2hhcikge1xuICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICAgIHJldHVybiB7IHllYXI6IG51bWVyaWModG9rZW4ud2lkdGgpIH07XG4gICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgcmV0dXJuIHsgY2FsZW5kYXI6ICdncmVnb3J5JywgeWVhcjogJ251bWVyaWMnIH07XG4gICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICBjYXNlICdVJzpcbiAgICAgICAgY2FzZSAnWSc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBvbkVycm9yKGAke3Rva2VuLmRlc2N9IGlzIG5vdCBzdXBwb3J0ZWQ7IGZhbGxpbmcgYmFjayB0byB5ZWFyOm51bWVyaWNgLCBEYXRlRm9ybWF0RXJyb3IuV0FSTklORyk7XG4gICAgICAgICAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBtb250aFN0eWxlKHRva2VuLCBvbkVycm9yKSB7XG4gICAgc3dpdGNoICh0b2tlbi53aWR0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gJ251bWVyaWMnO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gJzItZGlnaXQnO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gJ3Nob3J0JztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuICdsb25nJztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuICduYXJyb3cnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgb25FcnJvcihgJHt0b2tlbi5kZXNjfSBpcyBub3Qgc3VwcG9ydGVkIHdpdGggd2lkdGggJHt0b2tlbi53aWR0aH1gKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gZGF5U3R5bGUodG9rZW4sIG9uRXJyb3IpIHtcbiAgICBjb25zdCB7IGNoYXIsIGRlc2MsIHdpZHRoIH0gPSB0b2tlbjtcbiAgICBpZiAoY2hhciA9PT0gJ2QnKSB7XG4gICAgICAgIHJldHVybiBudW1lcmljKHdpZHRoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9uRXJyb3IoYCR7ZGVzY30gaXMgbm90IHN1cHBvcnRlZGApO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHdlZWtkYXlTdHlsZSh0b2tlbiwgb25FcnJvcikge1xuICAgIGNvbnN0IHsgY2hhciwgZGVzYywgd2lkdGggfSA9IHRva2VuO1xuICAgIGlmICgoY2hhciA9PT0gJ2MnIHx8IGNoYXIgPT09ICdlJykgJiYgd2lkdGggPCAzKSB7XG4gICAgICAgIC8vIGlnbm9yaW5nIHN0YW5kLWFsb25lLW5lc3NcbiAgICAgICAgY29uc3QgbXNnID0gYE51bWVyaWMgdmFsdWUgaXMgbm90IHN1cHBvcnRlZCBmb3IgJHtkZXNjfTsgZmFsbGluZyBiYWNrIHRvIHdlZWtkYXk6c2hvcnRgO1xuICAgICAgICBvbkVycm9yKG1zZywgRGF0ZUZvcm1hdEVycm9yLldBUk5JTkcpO1xuICAgIH1cbiAgICAvLyBtZXJnaW5nIG5hcnJvdyBzdHlsZXNcbiAgICByZXR1cm4gYWxwaGEod2lkdGgpO1xufVxuZnVuY3Rpb24gaG91ck9wdGlvbnModG9rZW4pIHtcbiAgICBjb25zdCBob3VyID0gbnVtZXJpYyh0b2tlbi53aWR0aCk7XG4gICAgbGV0IGhvdXJDeWNsZTtcbiAgICBzd2l0Y2ggKHRva2VuLmNoYXIpIHtcbiAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICBob3VyQ3ljbGUgPSAnaDEyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICAgIGhvdXJDeWNsZSA9ICdoMjMnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2snOlxuICAgICAgICAgICAgaG91ckN5Y2xlID0gJ2gyNCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnSyc6XG4gICAgICAgICAgICBob3VyQ3ljbGUgPSAnaDExJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gaG91ckN5Y2xlID8geyBob3VyLCBob3VyQ3ljbGUgfSA6IHsgaG91ciB9O1xufVxuZnVuY3Rpb24gdGltZVpvbmVOYW1lU3R5bGUodG9rZW4sIG9uRXJyb3IpIHtcbiAgICAvLyBzbyBtdWNoIGZhbGxiYWNrIGJlaGF2aW91ciBoZXJlXG4gICAgY29uc3QgeyBjaGFyLCBkZXNjLCB3aWR0aCB9ID0gdG9rZW47XG4gICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAgIHJldHVybiB3aWR0aCA9PT0gNCA/ICdsb25nJyA6ICdzaG9ydCc7XG4gICAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAgICAgaWYgKHdpZHRoID09PSA0KVxuICAgICAgICAgICAgICAgIHJldHVybiAnbG9uZyc7XG4gICAgICAgICAgICBvbkVycm9yKGAke2Rlc2N9IGlzIG5vdCBzdXBwb3J0ZWQgd2l0aCB3aWR0aCAke3dpZHRofWApO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgY2FzZSAnWCc6XG4gICAgICAgICAgICBvbkVycm9yKGAke2Rlc2N9IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiAnc2hvcnQnO1xufVxuZnVuY3Rpb24gY29tcGlsZU9wdGlvbnModG9rZW4sIG9uRXJyb3IpIHtcbiAgICBzd2l0Y2ggKHRva2VuLmZpZWxkKSB7XG4gICAgICAgIGNhc2UgJ2VyYSc6XG4gICAgICAgICAgICByZXR1cm4geyBlcmE6IGFscGhhKHRva2VuLndpZHRoKSB9O1xuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgIHJldHVybiB5ZWFyT3B0aW9ucyh0b2tlbiwgb25FcnJvcik7XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgIHJldHVybiB7IG1vbnRoOiBtb250aFN0eWxlKHRva2VuLCBvbkVycm9yKSB9O1xuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgcmV0dXJuIHsgZGF5OiBkYXlTdHlsZSh0b2tlbiwgb25FcnJvcikgfTtcbiAgICAgICAgY2FzZSAnd2Vla2RheSc6XG4gICAgICAgICAgICByZXR1cm4geyB3ZWVrZGF5OiB3ZWVrZGF5U3R5bGUodG9rZW4sIG9uRXJyb3IpIH07XG4gICAgICAgIGNhc2UgJ3BlcmlvZCc6XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgIHJldHVybiBob3VyT3B0aW9ucyh0b2tlbik7XG4gICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgICAgICByZXR1cm4geyBtaW51dGU6IG51bWVyaWModG9rZW4ud2lkdGgpIH07XG4gICAgICAgIGNhc2UgJ3NlYyc6XG4gICAgICAgICAgICByZXR1cm4geyBzZWNvbmQ6IG51bWVyaWModG9rZW4ud2lkdGgpIH07XG4gICAgICAgIGNhc2UgJ3R6JzpcbiAgICAgICAgICAgIHJldHVybiB7IHRpbWVab25lTmFtZTogdGltZVpvbmVOYW1lU3R5bGUodG9rZW4sIG9uRXJyb3IpIH07XG4gICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgY2FzZSAnc2VjLWZyYWMnOlxuICAgICAgICBjYXNlICdtcyc6XG4gICAgICAgICAgICBvbkVycm9yKGAke3Rva2VuLmRlc2N9IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldERhdGVGb3JtYXRPcHRpb25zKHRva2VucywgdGltZVpvbmUsIG9uRXJyb3IgPSBlcnJvciA9PiB7XG4gICAgdGhyb3cgZXJyb3I7XG59KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgdGltZVpvbmVcbiAgICB9O1xuICAgIGNvbnN0IGZpZWxkcyA9IFtdO1xuICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAgIGNvbnN0IHsgZXJyb3IsIGZpZWxkLCBzdHIgfSA9IHRva2VuO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGR0ZSA9IG5ldyBEYXRlRm9ybWF0RXJyb3IoZXJyb3IubWVzc2FnZSwgdG9rZW4pO1xuICAgICAgICAgICAgZHRlLnN0YWNrID0gZXJyb3Iuc3RhY2s7XG4gICAgICAgICAgICBvbkVycm9yKGR0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYElnbm9yaW5nIHN0cmluZyBwYXJ0OiAke3N0cn1gO1xuICAgICAgICAgICAgb25FcnJvcihuZXcgRGF0ZUZvcm1hdEVycm9yKG1zZywgdG9rZW4sIERhdGVGb3JtYXRFcnJvci5XQVJOSU5HKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgICAgICBpZiAoZmllbGRzLmluZGV4T2YoZmllbGQpID09PSAtMSlcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChmaWVsZCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgb25FcnJvcihuZXcgRGF0ZUZvcm1hdEVycm9yKGBEdXBsaWNhdGUgJHtmaWVsZH0gdG9rZW5gLCB0b2tlbikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdCA9IGNvbXBpbGVPcHRpb25zKHRva2VuLCAobXNnLCBpc1dhcm5pbmcpID0+IG9uRXJyb3IobmV3IERhdGVGb3JtYXRFcnJvcihtc2csIHRva2VuLCBpc1dhcm5pbmcpKSk7XG4gICAgICAgIGlmIChvcHQpXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIG9wdCk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuXG5jb25zdCBmaWVsZHMgPSB7XG4gICAgRzogeyBmaWVsZDogJ2VyYScsIGRlc2M6ICdFcmEnIH0sXG4gICAgeTogeyBmaWVsZDogJ3llYXInLCBkZXNjOiAnWWVhcicgfSxcbiAgICBZOiB7IGZpZWxkOiAneWVhcicsIGRlc2M6ICdZZWFyIG9mIFwiV2VlayBvZiBZZWFyXCInIH0sXG4gICAgdTogeyBmaWVsZDogJ3llYXInLCBkZXNjOiAnRXh0ZW5kZWQgeWVhcicgfSxcbiAgICBVOiB7IGZpZWxkOiAneWVhcicsIGRlc2M6ICdDeWNsaWMgeWVhciBuYW1lJyB9LFxuICAgIHI6IHsgZmllbGQ6ICd5ZWFyJywgZGVzYzogJ1JlbGF0ZWQgR3JlZ29yaWFuIHllYXInIH0sXG4gICAgUTogeyBmaWVsZDogJ3F1YXJ0ZXInLCBkZXNjOiAnUXVhcnRlcicgfSxcbiAgICBxOiB7IGZpZWxkOiAncXVhcnRlcicsIGRlc2M6ICdTdGFuZC1hbG9uZSBxdWFydGVyJyB9LFxuICAgIE06IHsgZmllbGQ6ICdtb250aCcsIGRlc2M6ICdNb250aCBpbiB5ZWFyJyB9LFxuICAgIEw6IHsgZmllbGQ6ICdtb250aCcsIGRlc2M6ICdTdGFuZC1hbG9uZSBtb250aCBpbiB5ZWFyJyB9LFxuICAgIHc6IHsgZmllbGQ6ICd3ZWVrJywgZGVzYzogJ1dlZWsgb2YgeWVhcicgfSxcbiAgICBXOiB7IGZpZWxkOiAnd2VlaycsIGRlc2M6ICdXZWVrIG9mIG1vbnRoJyB9LFxuICAgIGQ6IHsgZmllbGQ6ICdkYXknLCBkZXNjOiAnRGF5IGluIG1vbnRoJyB9LFxuICAgIEQ6IHsgZmllbGQ6ICdkYXknLCBkZXNjOiAnRGF5IG9mIHllYXInIH0sXG4gICAgRjogeyBmaWVsZDogJ2RheScsIGRlc2M6ICdEYXkgb2Ygd2VlayBpbiBtb250aCcgfSxcbiAgICBnOiB7IGZpZWxkOiAnZGF5JywgZGVzYzogJ01vZGlmaWVkIGp1bGlhbiBkYXknIH0sXG4gICAgRTogeyBmaWVsZDogJ3dlZWtkYXknLCBkZXNjOiAnRGF5IG9mIHdlZWsnIH0sXG4gICAgZTogeyBmaWVsZDogJ3dlZWtkYXknLCBkZXNjOiAnTG9jYWwgZGF5IG9mIHdlZWsnIH0sXG4gICAgYzogeyBmaWVsZDogJ3dlZWtkYXknLCBkZXNjOiAnU3RhbmQtYWxvbmUgbG9jYWwgZGF5IG9mIHdlZWsnIH0sXG4gICAgYTogeyBmaWVsZDogJ3BlcmlvZCcsIGRlc2M6ICdBTS9QTSBtYXJrZXInIH0sXG4gICAgYjogeyBmaWVsZDogJ3BlcmlvZCcsIGRlc2M6ICdBTS9QTS9ub29uL21pZG5pZ2h0IG1hcmtlcicgfSxcbiAgICBCOiB7IGZpZWxkOiAncGVyaW9kJywgZGVzYzogJ0ZsZXhpYmxlIGRheSBwZXJpb2QnIH0sXG4gICAgaDogeyBmaWVsZDogJ2hvdXInLCBkZXNjOiAnSG91ciBpbiBBTS9QTSAoMX4xMiknIH0sXG4gICAgSDogeyBmaWVsZDogJ2hvdXInLCBkZXNjOiAnSG91ciBpbiBkYXkgKDB+MjMpJyB9LFxuICAgIGs6IHsgZmllbGQ6ICdob3VyJywgZGVzYzogJ0hvdXIgaW4gZGF5ICgxfjI0KScgfSxcbiAgICBLOiB7IGZpZWxkOiAnaG91cicsIGRlc2M6ICdIb3VyIGluIEFNL1BNICgwfjExKScgfSxcbiAgICBqOiB7IGZpZWxkOiAnaG91cicsIGRlc2M6ICdIb3VyIGluIHByZWZlcnJlZCBjeWNsZScgfSxcbiAgICBKOiB7IGZpZWxkOiAnaG91cicsIGRlc2M6ICdIb3VyIGluIHByZWZlcnJlZCBjeWNsZSB3aXRob3V0IG1hcmtlcicgfSxcbiAgICBDOiB7IGZpZWxkOiAnaG91cicsIGRlc2M6ICdIb3VyIGluIHByZWZlcnJlZCBjeWNsZSB3aXRoIGZsZXhpYmxlIG1hcmtlcicgfSxcbiAgICBtOiB7IGZpZWxkOiAnbWluJywgZGVzYzogJ01pbnV0ZSBpbiBob3VyJyB9LFxuICAgIHM6IHsgZmllbGQ6ICdzZWMnLCBkZXNjOiAnU2Vjb25kIGluIG1pbnV0ZScgfSxcbiAgICBTOiB7IGZpZWxkOiAnc2VjLWZyYWMnLCBkZXNjOiAnRnJhY3Rpb25hbCBzZWNvbmQnIH0sXG4gICAgQTogeyBmaWVsZDogJ21zJywgZGVzYzogJ01pbGxpc2Vjb25kcyBpbiBkYXknIH0sXG4gICAgejogeyBmaWVsZDogJ3R6JywgZGVzYzogJ1RpbWUgWm9uZTogc3BlY2lmaWMgbm9uLWxvY2F0aW9uJyB9LFxuICAgIFo6IHsgZmllbGQ6ICd0eicsIGRlc2M6ICdUaW1lIFpvbmUnIH0sXG4gICAgTzogeyBmaWVsZDogJ3R6JywgZGVzYzogJ1RpbWUgWm9uZTogbG9jYWxpemVkJyB9LFxuICAgIHY6IHsgZmllbGQ6ICd0eicsIGRlc2M6ICdUaW1lIFpvbmU6IGdlbmVyaWMgbm9uLWxvY2F0aW9uJyB9LFxuICAgIFY6IHsgZmllbGQ6ICd0eicsIGRlc2M6ICdUaW1lIFpvbmU6IElEJyB9LFxuICAgIFg6IHsgZmllbGQ6ICd0eicsIGRlc2M6ICdUaW1lIFpvbmU6IElTTzg2MDEgd2l0aCBaJyB9LFxuICAgIHg6IHsgZmllbGQ6ICd0eicsIGRlc2M6ICdUaW1lIFpvbmU6IElTTzg2MDEnIH1cbn07XG5jb25zdCBpc0xldHRlciA9IChjaGFyKSA9PiAoY2hhciA+PSAnQScgJiYgY2hhciA8PSAnWicpIHx8IChjaGFyID49ICdhJyAmJiBjaGFyIDw9ICd6Jyk7XG5mdW5jdGlvbiByZWFkRmllbGRUb2tlbihzcmMsIHBvcykge1xuICAgIGNvbnN0IGNoYXIgPSBzcmNbcG9zXTtcbiAgICBsZXQgd2lkdGggPSAxO1xuICAgIHdoaWxlIChzcmNbKytwb3NdID09PSBjaGFyKVxuICAgICAgICArK3dpZHRoO1xuICAgIGNvbnN0IGZpZWxkID0gZmllbGRzW2NoYXJdO1xuICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgY29uc3QgbXNnID0gYFRoZSBsZXR0ZXIgJHtjaGFyfSBpcyBub3QgYSB2YWxpZCBmaWVsZCBpZGVudGlmaWVyYDtcbiAgICAgICAgcmV0dXJuIHsgY2hhciwgZXJyb3I6IG5ldyBFcnJvcihtc2cpLCB3aWR0aCB9O1xuICAgIH1cbiAgICByZXR1cm4geyBjaGFyLCBmaWVsZDogZmllbGQuZmllbGQsIGRlc2M6IGZpZWxkLmRlc2MsIHdpZHRoIH07XG59XG5mdW5jdGlvbiByZWFkUXVvdGVkVG9rZW4oc3JjLCBwb3MpIHtcbiAgICBsZXQgc3RyID0gc3JjWysrcG9zXTtcbiAgICBsZXQgd2lkdGggPSAyO1xuICAgIGlmIChzdHIgPT09IFwiJ1wiKVxuICAgICAgICByZXR1cm4geyBjaGFyOiBcIidcIiwgc3RyLCB3aWR0aCB9O1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSBzcmNbKytwb3NdO1xuICAgICAgICArK3dpZHRoO1xuICAgICAgICBpZiAobmV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBgVW50ZXJtaW5hdGVkIHF1b3RlZCBsaXRlcmFsIGluIHBhdHRlcm46ICR7c3RyIHx8IHNyY31gO1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhcjogXCInXCIsIGVycm9yOiBuZXcgRXJyb3IobXNnKSwgc3RyLCB3aWR0aCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5leHQgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICBpZiAoc3JjWysrcG9zXSAhPT0gXCInXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhcjogXCInXCIsIHN0ciwgd2lkdGggfTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICArK3dpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHN0ciArPSBuZXh0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlYWRUb2tlbihzcmMsIHBvcykge1xuICAgIGNvbnN0IGNoYXIgPSBzcmNbcG9zXTtcbiAgICBpZiAoIWNoYXIpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChpc0xldHRlcihjaGFyKSlcbiAgICAgICAgcmV0dXJuIHJlYWRGaWVsZFRva2VuKHNyYywgcG9zKTtcbiAgICBpZiAoY2hhciA9PT0gXCInXCIpXG4gICAgICAgIHJldHVybiByZWFkUXVvdGVkVG9rZW4oc3JjLCBwb3MpO1xuICAgIGxldCBzdHIgPSBjaGFyO1xuICAgIGxldCB3aWR0aCA9IDE7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IHNyY1srK3Bvc107XG4gICAgICAgIGlmICghbmV4dCB8fCBpc0xldHRlcihuZXh0KSB8fCBuZXh0ID09PSBcIidcIilcbiAgICAgICAgICAgIHJldHVybiB7IGNoYXIsIHN0ciwgd2lkdGggfTtcbiAgICAgICAgc3RyICs9IG5leHQ7XG4gICAgICAgIHdpZHRoICs9IDE7XG4gICAgfVxufVxuLyoqXG4gKiBQYXJzZSBhbiB7QGxpbmsgaHR0cDovL3VzZXJndWlkZS5pY3UtcHJvamVjdC5vcmcvZm9ybWF0cGFyc2UvZGF0ZXRpbWUgfCBJQ1VcbiAqIERhdGVGb3JtYXQgc2tlbGV0b259IHN0cmluZyBpbnRvIGEge0BsaW5rIERhdGVUb2tlbn0gYXJyYXkuXG4gKlxuICogQHJlbWFya3NcbiAqIEVycm9ycyB3aWxsIG5vdCBiZSB0aHJvd24sIGJ1dCBpZiBlbmNvdW50ZXJlZCBhcmUgaW5jbHVkZWQgYXMgdGhlIHJlbGV2YW50XG4gKiB0b2tlbidzIGBlcnJvcmAgdmFsdWUuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHNyYyAtIFRoZSBza2VsZXRvbiBzdHJpbmdcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGltcG9ydCB7IHBhcnNlRGF0ZVRva2VucyB9IGZyb20gJ0BtZXNzYWdlZm9ybWF0L2RhdGUtc2tlbGV0b24nXG4gKlxuICogcGFyc2VEYXRlVG9rZW5zKCdHck1NTWRkJywgY29uc29sZS5lcnJvcilcbiAqIC8vIFtcbiAqIC8vICAgeyBjaGFyOiAnRycsIGZpZWxkOiAnZXJhJywgZGVzYzogJ0VyYScsIHdpZHRoOiAxIH0sXG4gKiAvLyAgIHsgY2hhcjogJ3InLCBmaWVsZDogJ3llYXInLCBkZXNjOiAnUmVsYXRlZCBHcmVnb3JpYW4geWVhcicsIHdpZHRoOiAxIH0sXG4gKiAvLyAgIHsgY2hhcjogJ00nLCBmaWVsZDogJ21vbnRoJywgZGVzYzogJ01vbnRoIGluIHllYXInLCB3aWR0aDogMyB9LFxuICogLy8gICB7IGNoYXI6ICdkJywgZmllbGQ6ICdkYXknLCBkZXNjOiAnRGF5IGluIG1vbnRoJywgd2lkdGg6IDIgfVxuICogLy8gXVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRGF0ZVRva2VucyhzcmMpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICBsZXQgcG9zID0gMDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB0b2tlbiA9IHJlYWRUb2tlbihzcmMsIHBvcyk7XG4gICAgICAgIGlmICghdG9rZW4pXG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIHBvcyArPSB0b2tlbi53aWR0aDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NUb2tlbnModG9rZW5zLCBtYXBUZXh0KSB7XG4gIGlmICghdG9rZW5zLmZpbHRlcigodG9rZW4pID0+IHRva2VuLnR5cGUgIT09IFwiY29udGVudFwiKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gdG9rZW5zLm1hcCgodG9rZW4pID0+IG1hcFRleHQodG9rZW4udmFsdWUpKTtcbiAgfVxuICByZXR1cm4gdG9rZW5zLm1hcCgodG9rZW4pID0+IHtcbiAgICBpZiAodG9rZW4udHlwZSA9PT0gXCJjb250ZW50XCIpIHtcbiAgICAgIHJldHVybiBtYXBUZXh0KHRva2VuLnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IFwib2N0b3Rob3JwZVwiKSB7XG4gICAgICByZXR1cm4gXCIjXCI7XG4gICAgfSBlbHNlIGlmICh0b2tlbi50eXBlID09PSBcImFyZ3VtZW50XCIpIHtcbiAgICAgIHJldHVybiBbdG9rZW4uYXJnXTtcbiAgICB9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29uc3QgX3BhcmFtID0gdG9rZW4/LnBhcmFtPy5bMF07XG4gICAgICBpZiAodG9rZW4ua2V5ID09PSBcImRhdGVcIiAmJiBfcGFyYW0pIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IGNvbXBpbGVEYXRlRXhwcmVzc2lvbihfcGFyYW0udmFsdWUudHJpbSgpLCAoZSkgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGNvbXBpbGUgZGF0ZSBleHByZXNzaW9uOiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbdG9rZW4uYXJnLCB0b2tlbi5rZXksIG9wdHNdO1xuICAgICAgfVxuICAgICAgaWYgKF9wYXJhbSkge1xuICAgICAgICByZXR1cm4gW3Rva2VuLmFyZywgdG9rZW4ua2V5LCBfcGFyYW0udmFsdWUudHJpbSgpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbdG9rZW4uYXJnLCB0b2tlbi5rZXldO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvZmZzZXQgPSB0b2tlbi5wbHVyYWxPZmZzZXQ7XG4gICAgY29uc3QgZm9ybWF0UHJvcHMgPSB7fTtcbiAgICB0b2tlbi5jYXNlcy5mb3JFYWNoKCh7IGtleSwgdG9rZW5zOiB0b2tlbnMyIH0pID0+IHtcbiAgICAgIGNvbnN0IHByb3AgPSBrZXlbMF0gPT09IFwiPVwiID8ga2V5LnNsaWNlKDEpIDoga2V5O1xuICAgICAgZm9ybWF0UHJvcHNbcHJvcF0gPSBwcm9jZXNzVG9rZW5zKHRva2VuczIsIG1hcFRleHQpO1xuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICB0b2tlbi5hcmcsXG4gICAgICB0b2tlbi50eXBlLFxuICAgICAge1xuICAgICAgICBvZmZzZXQsXG4gICAgICAgIC4uLmZvcm1hdFByb3BzXG4gICAgICB9XG4gICAgXTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjb21waWxlRGF0ZUV4cHJlc3Npb24oZm9ybWF0LCBvbkVycm9yKSB7XG4gIGlmICgvXjo6Ly50ZXN0KGZvcm1hdCkpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBwYXJzZURhdGVUb2tlbnMoZm9ybWF0LnN1YnN0cmluZygyKSk7XG4gICAgcmV0dXJuIGdldERhdGVGb3JtYXRPcHRpb25zKHRva2Vucywgdm9pZCAwLCBvbkVycm9yKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0O1xufVxuZnVuY3Rpb24gY29tcGlsZU1lc3NhZ2VPclRocm93KG1lc3NhZ2UsIG1hcFRleHQgPSAodikgPT4gdikge1xuICByZXR1cm4gcHJvY2Vzc1Rva2VucyhwYXJzZShtZXNzYWdlKSwgbWFwVGV4dCk7XG59XG5mdW5jdGlvbiBjb21waWxlTWVzc2FnZShtZXNzYWdlLCBtYXBUZXh0ID0gKHYpID0+IHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gY29tcGlsZU1lc3NhZ2VPclRocm93KG1lc3NhZ2UsIG1hcFRleHQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihgJHtlLm1lc3NhZ2V9IFxuXG5NZXNzYWdlOiAke21lc3NhZ2V9YCk7XG4gICAgcmV0dXJuIFttZXNzYWdlXTtcbiAgfVxufVxuXG5leHBvcnQgeyBjb21waWxlTWVzc2FnZSwgY29tcGlsZU1lc3NhZ2VPclRocm93IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@lingui+message-utils@5.3.1/node_modules/@lingui/message-utils/dist/compileMessage.mjs\n");

/***/ })

};
;