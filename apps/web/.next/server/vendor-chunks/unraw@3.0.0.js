"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/unraw@3.0.0";
exports.ids = ["vendor-chunks/unraw@3.0.0"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/unraw@3.0.0/node_modules/unraw/dist/errors.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/.pnpm/unraw@3.0.0/node_modules/unraw/dist/errors.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// NOTE: don't construct errors here or they'll have the wrong stack trace.\n// NOTE: don't make custom error class; the JS engines use `SyntaxError`\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.errorMessages = exports.ErrorType = void 0;\n/**\n * Keys for possible error messages used by `unraw`.\n * Note: These do _not_ map to actual error object types. All errors thrown\n * are `SyntaxError`.\n */\n// Don't use const enum or JS users won't be able to access the enum values\nvar ErrorType;\n(function (ErrorType) {\n    /**\n     * Thrown when a badly formed Unicode escape sequence is found. Possible\n     * reasons include the code being too short (`\"\\u25\"`) or having invalid\n     * characters (`\"\\u2$A5\"`).\n     */\n    ErrorType[\"MalformedUnicode\"] = \"MALFORMED_UNICODE\";\n    /**\n     * Thrown when a badly formed hexadecimal escape sequence is found. Possible\n     * reasons include the code being too short (`\"\\x2\"`) or having invalid\n     * characters (`\"\\x2$\"`).\n     */\n    ErrorType[\"MalformedHexadecimal\"] = \"MALFORMED_HEXADECIMAL\";\n    /**\n     * Thrown when a Unicode code point escape sequence has too high of a code\n     * point. The maximum code point allowed is `\\u{10FFFF}`, so `\\u{110000}` and\n     * higher will throw this error.\n     */\n    ErrorType[\"CodePointLimit\"] = \"CODE_POINT_LIMIT\";\n    /**\n     * Thrown when an octal escape sequences is encountered and `allowOctals` is\n     * `false`. For example, `unraw(\"\\234\", false)`.\n     */\n    ErrorType[\"OctalDeprecation\"] = \"OCTAL_DEPRECATION\";\n    /**\n     * Thrown only when a single backslash is found at the end of a string. For\n     * example, `\"\\\\\"` or `\"test\\\\x24\\\\\"`.\n     */\n    ErrorType[\"EndOfString\"] = \"END_OF_STRING\";\n})(ErrorType = exports.ErrorType || (exports.ErrorType = {}));\n/** Map of error message names to the full text of the message. */\nexports.errorMessages = new Map([\n    [ErrorType.MalformedUnicode, \"malformed Unicode character escape sequence\"],\n    [\n        ErrorType.MalformedHexadecimal,\n        \"malformed hexadecimal character escape sequence\"\n    ],\n    [\n        ErrorType.CodePointLimit,\n        \"Unicode codepoint must not be greater than 0x10FFFF in escape sequence\"\n    ],\n    [\n        ErrorType.OctalDeprecation,\n        '\"0\"-prefixed octal literals and octal escape sequences are deprecated; ' +\n            'for octal literals use the \"0o\" prefix instead'\n    ],\n    [ErrorType.EndOfString, \"malformed escape sequence at end of string\"]\n]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VucmF3QDMuMC4wL25vZGVfbW9kdWxlcy91bnJhdy9kaXN0L2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0Esd0NBQXdDO0FBQ3hDLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyxpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsT0FBTyxVQUFVLE9BQU87QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQyxpQkFBaUIsS0FBSztBQUMzRDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXJ0ZW0uc3RlcGFub3YvZnJvbnRlbmQtbW9uby9ub2RlX21vZHVsZXMvLnBucG0vdW5yYXdAMy4wLjAvbm9kZV9tb2R1bGVzL3VucmF3L2Rpc3QvZXJyb3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gTk9URTogZG9uJ3QgY29uc3RydWN0IGVycm9ycyBoZXJlIG9yIHRoZXknbGwgaGF2ZSB0aGUgd3Jvbmcgc3RhY2sgdHJhY2UuXG4vLyBOT1RFOiBkb24ndCBtYWtlIGN1c3RvbSBlcnJvciBjbGFzczsgdGhlIEpTIGVuZ2luZXMgdXNlIGBTeW50YXhFcnJvcmBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXJyb3JNZXNzYWdlcyA9IGV4cG9ydHMuRXJyb3JUeXBlID0gdm9pZCAwO1xuLyoqXG4gKiBLZXlzIGZvciBwb3NzaWJsZSBlcnJvciBtZXNzYWdlcyB1c2VkIGJ5IGB1bnJhd2AuXG4gKiBOb3RlOiBUaGVzZSBkbyBfbm90XyBtYXAgdG8gYWN0dWFsIGVycm9yIG9iamVjdCB0eXBlcy4gQWxsIGVycm9ycyB0aHJvd25cbiAqIGFyZSBgU3ludGF4RXJyb3JgLlxuICovXG4vLyBEb24ndCB1c2UgY29uc3QgZW51bSBvciBKUyB1c2VycyB3b24ndCBiZSBhYmxlIHRvIGFjY2VzcyB0aGUgZW51bSB2YWx1ZXNcbnZhciBFcnJvclR5cGU7XG4oZnVuY3Rpb24gKEVycm9yVHlwZSkge1xuICAgIC8qKlxuICAgICAqIFRocm93biB3aGVuIGEgYmFkbHkgZm9ybWVkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlIGlzIGZvdW5kLiBQb3NzaWJsZVxuICAgICAqIHJlYXNvbnMgaW5jbHVkZSB0aGUgY29kZSBiZWluZyB0b28gc2hvcnQgKGBcIlxcdTI1XCJgKSBvciBoYXZpbmcgaW52YWxpZFxuICAgICAqIGNoYXJhY3RlcnMgKGBcIlxcdTIkQTVcImApLlxuICAgICAqL1xuICAgIEVycm9yVHlwZVtcIk1hbGZvcm1lZFVuaWNvZGVcIl0gPSBcIk1BTEZPUk1FRF9VTklDT0RFXCI7XG4gICAgLyoqXG4gICAgICogVGhyb3duIHdoZW4gYSBiYWRseSBmb3JtZWQgaGV4YWRlY2ltYWwgZXNjYXBlIHNlcXVlbmNlIGlzIGZvdW5kLiBQb3NzaWJsZVxuICAgICAqIHJlYXNvbnMgaW5jbHVkZSB0aGUgY29kZSBiZWluZyB0b28gc2hvcnQgKGBcIlxceDJcImApIG9yIGhhdmluZyBpbnZhbGlkXG4gICAgICogY2hhcmFjdGVycyAoYFwiXFx4MiRcImApLlxuICAgICAqL1xuICAgIEVycm9yVHlwZVtcIk1hbGZvcm1lZEhleGFkZWNpbWFsXCJdID0gXCJNQUxGT1JNRURfSEVYQURFQ0lNQUxcIjtcbiAgICAvKipcbiAgICAgKiBUaHJvd24gd2hlbiBhIFVuaWNvZGUgY29kZSBwb2ludCBlc2NhcGUgc2VxdWVuY2UgaGFzIHRvbyBoaWdoIG9mIGEgY29kZVxuICAgICAqIHBvaW50LiBUaGUgbWF4aW11bSBjb2RlIHBvaW50IGFsbG93ZWQgaXMgYFxcdXsxMEZGRkZ9YCwgc28gYFxcdXsxMTAwMDB9YCBhbmRcbiAgICAgKiBoaWdoZXIgd2lsbCB0aHJvdyB0aGlzIGVycm9yLlxuICAgICAqL1xuICAgIEVycm9yVHlwZVtcIkNvZGVQb2ludExpbWl0XCJdID0gXCJDT0RFX1BPSU5UX0xJTUlUXCI7XG4gICAgLyoqXG4gICAgICogVGhyb3duIHdoZW4gYW4gb2N0YWwgZXNjYXBlIHNlcXVlbmNlcyBpcyBlbmNvdW50ZXJlZCBhbmQgYGFsbG93T2N0YWxzYCBpc1xuICAgICAqIGBmYWxzZWAuIEZvciBleGFtcGxlLCBgdW5yYXcoXCJcXDIzNFwiLCBmYWxzZSlgLlxuICAgICAqL1xuICAgIEVycm9yVHlwZVtcIk9jdGFsRGVwcmVjYXRpb25cIl0gPSBcIk9DVEFMX0RFUFJFQ0FUSU9OXCI7XG4gICAgLyoqXG4gICAgICogVGhyb3duIG9ubHkgd2hlbiBhIHNpbmdsZSBiYWNrc2xhc2ggaXMgZm91bmQgYXQgdGhlIGVuZCBvZiBhIHN0cmluZy4gRm9yXG4gICAgICogZXhhbXBsZSwgYFwiXFxcXFwiYCBvciBgXCJ0ZXN0XFxcXHgyNFxcXFxcImAuXG4gICAgICovXG4gICAgRXJyb3JUeXBlW1wiRW5kT2ZTdHJpbmdcIl0gPSBcIkVORF9PRl9TVFJJTkdcIjtcbn0pKEVycm9yVHlwZSA9IGV4cG9ydHMuRXJyb3JUeXBlIHx8IChleHBvcnRzLkVycm9yVHlwZSA9IHt9KSk7XG4vKiogTWFwIG9mIGVycm9yIG1lc3NhZ2UgbmFtZXMgdG8gdGhlIGZ1bGwgdGV4dCBvZiB0aGUgbWVzc2FnZS4gKi9cbmV4cG9ydHMuZXJyb3JNZXNzYWdlcyA9IG5ldyBNYXAoW1xuICAgIFtFcnJvclR5cGUuTWFsZm9ybWVkVW5pY29kZSwgXCJtYWxmb3JtZWQgVW5pY29kZSBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlXCJdLFxuICAgIFtcbiAgICAgICAgRXJyb3JUeXBlLk1hbGZvcm1lZEhleGFkZWNpbWFsLFxuICAgICAgICBcIm1hbGZvcm1lZCBoZXhhZGVjaW1hbCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlXCJcbiAgICBdLFxuICAgIFtcbiAgICAgICAgRXJyb3JUeXBlLkNvZGVQb2ludExpbWl0LFxuICAgICAgICBcIlVuaWNvZGUgY29kZXBvaW50IG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAweDEwRkZGRiBpbiBlc2NhcGUgc2VxdWVuY2VcIlxuICAgIF0sXG4gICAgW1xuICAgICAgICBFcnJvclR5cGUuT2N0YWxEZXByZWNhdGlvbixcbiAgICAgICAgJ1wiMFwiLXByZWZpeGVkIG9jdGFsIGxpdGVyYWxzIGFuZCBvY3RhbCBlc2NhcGUgc2VxdWVuY2VzIGFyZSBkZXByZWNhdGVkOyAnICtcbiAgICAgICAgICAgICdmb3Igb2N0YWwgbGl0ZXJhbHMgdXNlIHRoZSBcIjBvXCIgcHJlZml4IGluc3RlYWQnXG4gICAgXSxcbiAgICBbRXJyb3JUeXBlLkVuZE9mU3RyaW5nLCBcIm1hbGZvcm1lZCBlc2NhcGUgc2VxdWVuY2UgYXQgZW5kIG9mIHN0cmluZ1wiXVxuXSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/unraw@3.0.0/node_modules/unraw/dist/errors.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/unraw@3.0.0/node_modules/unraw/dist/index.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/.pnpm/unraw@3.0.0/node_modules/unraw/dist/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unraw = exports.errorMessages = exports.ErrorType = void 0;\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/../../node_modules/.pnpm/unraw@3.0.0/node_modules/unraw/dist/errors.js\");\nObject.defineProperty(exports, \"ErrorType\", ({ enumerable: true, get: function () { return errors_1.ErrorType; } }));\nObject.defineProperty(exports, \"errorMessages\", ({ enumerable: true, get: function () { return errors_1.errorMessages; } }));\n/**\n * Parse a string as a base-16 number. This is more strict than `parseInt` as it\n * will not allow any other characters, including (for example) \"+\", \"-\", and\n * \".\".\n * @param hex A string containing a hexadecimal number.\n * @returns The parsed integer, or `NaN` if the string is not a valid hex\n * number.\n */\nfunction parseHexToInt(hex) {\n    const isOnlyHexChars = !hex.match(/[^a-f0-9]/i);\n    return isOnlyHexChars ? parseInt(hex, 16) : NaN;\n}\n/**\n * Check the validity and length of a hexadecimal code and optionally enforces\n * a specific number of hex digits.\n * @param hex The string to validate and parse.\n * @param errorName The name of the error message to throw a `SyntaxError` with\n * if `hex` is invalid. This is used to index `errorMessages`.\n * @param enforcedLength If provided, will throw an error if `hex` is not\n * exactly this many characters.\n * @returns The parsed hex number as a normal number.\n * @throws {SyntaxError} If the code is not valid.\n */\nfunction validateAndParseHex(hex, errorName, enforcedLength) {\n    const parsedHex = parseHexToInt(hex);\n    if (Number.isNaN(parsedHex) ||\n        (enforcedLength !== undefined && enforcedLength !== hex.length)) {\n        throw new SyntaxError(errors_1.errorMessages.get(errorName));\n    }\n    return parsedHex;\n}\n/**\n * Parse a two-digit hexadecimal character escape code.\n * @param code The two-digit hexadecimal number that represents the character to\n * output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or is not the right\n * length.\n */\nfunction parseHexadecimalCode(code) {\n    const parsedCode = validateAndParseHex(code, errors_1.ErrorType.MalformedHexadecimal, 2);\n    return String.fromCharCode(parsedCode);\n}\n/**\n * Parse a four-digit Unicode character escape code.\n * @param code The four-digit unicode number that represents the character to\n * output.\n * @param surrogateCode Optional four-digit unicode surrogate that represents\n * the other half of the character to output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the codes are not valid hex or are not the right\n * length.\n */\nfunction parseUnicodeCode(code, surrogateCode) {\n    const parsedCode = validateAndParseHex(code, errors_1.ErrorType.MalformedUnicode, 4);\n    if (surrogateCode !== undefined) {\n        const parsedSurrogateCode = validateAndParseHex(surrogateCode, errors_1.ErrorType.MalformedUnicode, 4);\n        return String.fromCharCode(parsedCode, parsedSurrogateCode);\n    }\n    return String.fromCharCode(parsedCode);\n}\n/**\n * Test if the text is surrounded by curly braces (`{}`).\n * @param text Text to check.\n * @returns `true` if the text is in the form `{*}`.\n */\nfunction isCurlyBraced(text) {\n    return text.charAt(0) === \"{\" && text.charAt(text.length - 1) === \"}\";\n}\n/**\n * Parse a Unicode code point character escape code.\n * @param codePoint A unicode escape code point, including the surrounding curly\n * braces.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or does not have the\n * surrounding curly braces.\n */\nfunction parseUnicodeCodePointCode(codePoint) {\n    if (!isCurlyBraced(codePoint)) {\n        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.MalformedUnicode));\n    }\n    const withoutBraces = codePoint.slice(1, -1);\n    const parsedCode = validateAndParseHex(withoutBraces, errors_1.ErrorType.MalformedUnicode);\n    try {\n        return String.fromCodePoint(parsedCode);\n    }\n    catch (err) {\n        throw err instanceof RangeError\n            ? new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.CodePointLimit))\n            : err;\n    }\n}\n// Have to give overload that takes boolean for when compiler doesn't know if\n// true or false\nfunction parseOctalCode(code, error = false) {\n    if (error) {\n        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.OctalDeprecation));\n    }\n    // The original regex only allows digits so we don't need to have a strict\n    // octal parser like hexToInt. Length is not enforced for octals.\n    const parsedCode = parseInt(code, 8);\n    return String.fromCharCode(parsedCode);\n}\n/**\n * Map of unescaped letters to their corresponding special JS escape characters.\n * Intentionally does not include characters that map to themselves like \"\\'\".\n */\nconst singleCharacterEscapes = new Map([\n    [\"b\", \"\\b\"],\n    [\"f\", \"\\f\"],\n    [\"n\", \"\\n\"],\n    [\"r\", \"\\r\"],\n    [\"t\", \"\\t\"],\n    [\"v\", \"\\v\"],\n    [\"0\", \"\\0\"]\n]);\n/**\n * Parse a single character escape sequence and return the matching character.\n * If none is matched, defaults to `code`.\n * @param code A single character code.\n */\nfunction parseSingleCharacterCode(code) {\n    return singleCharacterEscapes.get(code) || code;\n}\n/**\n * Matches every escape sequence possible, including invalid ones.\n *\n * All capture groups (described below) are unique (only one will match), except\n * for 4, which can only potentially match if 3 does.\n *\n * **Capture Groups:**\n * 0. A single backslash\n * 1. Hexadecimal code\n * 2. Unicode code point code with surrounding curly braces\n * 3. Unicode escape code with surrogate\n * 4. Surrogate code\n * 5. Unicode escape code without surrogate\n * 6. Octal code _NOTE: includes \"0\"._\n * 7. A single character (will never be \\, x, u, or 0-3)\n */\nconst escapeMatch = /\\\\(?:(\\\\)|x([\\s\\S]{0,2})|u(\\{[^}]*\\}?)|u([\\s\\S]{4})\\\\u([^{][\\s\\S]{0,3})|u([\\s\\S]{0,4})|([0-3]?[0-7]{1,2})|([\\s\\S])|$)/g;\n/**\n * Replace raw escape character strings with their escape characters.\n * @param raw A string where escape characters are represented as raw string\n * values like `\\'` rather than `'`.\n * @param allowOctals If `true`, will process the now-deprecated octal escape\n * sequences (ie, `\\111`).\n * @returns The processed string, with escape characters replaced by their\n * respective actual Unicode characters.\n */\nfunction unraw(raw, allowOctals = false) {\n    return raw.replace(escapeMatch, function (_, backslash, hex, codePoint, unicodeWithSurrogate, surrogate, unicode, octal, singleCharacter) {\n        // Compare groups to undefined because empty strings mean different errors\n        // Otherwise, `\\u` would fail the same as `\\` which is wrong.\n        if (backslash !== undefined) {\n            return \"\\\\\";\n        }\n        if (hex !== undefined) {\n            return parseHexadecimalCode(hex);\n        }\n        if (codePoint !== undefined) {\n            return parseUnicodeCodePointCode(codePoint);\n        }\n        if (unicodeWithSurrogate !== undefined) {\n            return parseUnicodeCode(unicodeWithSurrogate, surrogate);\n        }\n        if (unicode !== undefined) {\n            return parseUnicodeCode(unicode);\n        }\n        if (octal === \"0\") {\n            return \"\\0\";\n        }\n        if (octal !== undefined) {\n            return parseOctalCode(octal, !allowOctals);\n        }\n        if (singleCharacter !== undefined) {\n            return parseSingleCharacterCode(singleCharacter);\n        }\n        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.EndOfString));\n    });\n}\nexports.unraw = unraw;\nexports[\"default\"] = unraw;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3VucmF3QDMuMC4wL25vZGVfbW9kdWxlcy91bnJhdy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsR0FBRyxxQkFBcUIsR0FBRyxpQkFBaUI7QUFDekQsaUJBQWlCLG1CQUFPLENBQUMsOEZBQVU7QUFDbkMsNkNBQTRDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ2xILGlEQUFnRCxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBLGdDQUFnQyx3Q0FBd0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSSxNQUFNLEdBQUcsSUFBSSxZQUFZLEVBQUUsUUFBUSxRQUFRLElBQUksV0FBVyxJQUFJLGVBQWUsSUFBSTtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYTtBQUNiLGtCQUFlIiwic291cmNlcyI6WyIvVXNlcnMvYXJ0ZW0uc3RlcGFub3YvZnJvbnRlbmQtbW9uby9ub2RlX21vZHVsZXMvLnBucG0vdW5yYXdAMy4wLjAvbm9kZV9tb2R1bGVzL3VucmF3L2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVucmF3ID0gZXhwb3J0cy5lcnJvck1lc3NhZ2VzID0gZXhwb3J0cy5FcnJvclR5cGUgPSB2b2lkIDA7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVycm9yVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3JzXzEuRXJyb3JUeXBlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXJyb3JNZXNzYWdlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3JzXzEuZXJyb3JNZXNzYWdlczsgfSB9KTtcbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgYXMgYSBiYXNlLTE2IG51bWJlci4gVGhpcyBpcyBtb3JlIHN0cmljdCB0aGFuIGBwYXJzZUludGAgYXMgaXRcbiAqIHdpbGwgbm90IGFsbG93IGFueSBvdGhlciBjaGFyYWN0ZXJzLCBpbmNsdWRpbmcgKGZvciBleGFtcGxlKSBcIitcIiwgXCItXCIsIGFuZFxuICogXCIuXCIuXG4gKiBAcGFyYW0gaGV4IEEgc3RyaW5nIGNvbnRhaW5pbmcgYSBoZXhhZGVjaW1hbCBudW1iZXIuXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIGludGVnZXIsIG9yIGBOYU5gIGlmIHRoZSBzdHJpbmcgaXMgbm90IGEgdmFsaWQgaGV4XG4gKiBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSGV4VG9JbnQoaGV4KSB7XG4gICAgY29uc3QgaXNPbmx5SGV4Q2hhcnMgPSAhaGV4Lm1hdGNoKC9bXmEtZjAtOV0vaSk7XG4gICAgcmV0dXJuIGlzT25seUhleENoYXJzID8gcGFyc2VJbnQoaGV4LCAxNikgOiBOYU47XG59XG4vKipcbiAqIENoZWNrIHRoZSB2YWxpZGl0eSBhbmQgbGVuZ3RoIG9mIGEgaGV4YWRlY2ltYWwgY29kZSBhbmQgb3B0aW9uYWxseSBlbmZvcmNlc1xuICogYSBzcGVjaWZpYyBudW1iZXIgb2YgaGV4IGRpZ2l0cy5cbiAqIEBwYXJhbSBoZXggVGhlIHN0cmluZyB0byB2YWxpZGF0ZSBhbmQgcGFyc2UuXG4gKiBAcGFyYW0gZXJyb3JOYW1lIFRoZSBuYW1lIG9mIHRoZSBlcnJvciBtZXNzYWdlIHRvIHRocm93IGEgYFN5bnRheEVycm9yYCB3aXRoXG4gKiBpZiBgaGV4YCBpcyBpbnZhbGlkLiBUaGlzIGlzIHVzZWQgdG8gaW5kZXggYGVycm9yTWVzc2FnZXNgLlxuICogQHBhcmFtIGVuZm9yY2VkTGVuZ3RoIElmIHByb3ZpZGVkLCB3aWxsIHRocm93IGFuIGVycm9yIGlmIGBoZXhgIGlzIG5vdFxuICogZXhhY3RseSB0aGlzIG1hbnkgY2hhcmFjdGVycy5cbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgaGV4IG51bWJlciBhcyBhIG5vcm1hbCBudW1iZXIuXG4gKiBAdGhyb3dzIHtTeW50YXhFcnJvcn0gSWYgdGhlIGNvZGUgaXMgbm90IHZhbGlkLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUFuZFBhcnNlSGV4KGhleCwgZXJyb3JOYW1lLCBlbmZvcmNlZExlbmd0aCkge1xuICAgIGNvbnN0IHBhcnNlZEhleCA9IHBhcnNlSGV4VG9JbnQoaGV4KTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHBhcnNlZEhleCkgfHxcbiAgICAgICAgKGVuZm9yY2VkTGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgZW5mb3JjZWRMZW5ndGggIT09IGhleC5sZW5ndGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihlcnJvcnNfMS5lcnJvck1lc3NhZ2VzLmdldChlcnJvck5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZEhleDtcbn1cbi8qKlxuICogUGFyc2UgYSB0d28tZGlnaXQgaGV4YWRlY2ltYWwgY2hhcmFjdGVyIGVzY2FwZSBjb2RlLlxuICogQHBhcmFtIGNvZGUgVGhlIHR3by1kaWdpdCBoZXhhZGVjaW1hbCBudW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSBjaGFyYWN0ZXIgdG9cbiAqIG91dHB1dC5cbiAqIEByZXR1cm5zIFRoZSBzaW5nbGUgY2hhcmFjdGVyIHJlcHJlc2VudGVkIGJ5IHRoZSBjb2RlLlxuICogQHRocm93cyB7U3ludGF4RXJyb3J9IElmIHRoZSBjb2RlIGlzIG5vdCB2YWxpZCBoZXggb3IgaXMgbm90IHRoZSByaWdodFxuICogbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBwYXJzZUhleGFkZWNpbWFsQ29kZShjb2RlKSB7XG4gICAgY29uc3QgcGFyc2VkQ29kZSA9IHZhbGlkYXRlQW5kUGFyc2VIZXgoY29kZSwgZXJyb3JzXzEuRXJyb3JUeXBlLk1hbGZvcm1lZEhleGFkZWNpbWFsLCAyKTtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZWRDb2RlKTtcbn1cbi8qKlxuICogUGFyc2UgYSBmb3VyLWRpZ2l0IFVuaWNvZGUgY2hhcmFjdGVyIGVzY2FwZSBjb2RlLlxuICogQHBhcmFtIGNvZGUgVGhlIGZvdXItZGlnaXQgdW5pY29kZSBudW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSBjaGFyYWN0ZXIgdG9cbiAqIG91dHB1dC5cbiAqIEBwYXJhbSBzdXJyb2dhdGVDb2RlIE9wdGlvbmFsIGZvdXItZGlnaXQgdW5pY29kZSBzdXJyb2dhdGUgdGhhdCByZXByZXNlbnRzXG4gKiB0aGUgb3RoZXIgaGFsZiBvZiB0aGUgY2hhcmFjdGVyIHRvIG91dHB1dC5cbiAqIEByZXR1cm5zIFRoZSBzaW5nbGUgY2hhcmFjdGVyIHJlcHJlc2VudGVkIGJ5IHRoZSBjb2RlLlxuICogQHRocm93cyB7U3ludGF4RXJyb3J9IElmIHRoZSBjb2RlcyBhcmUgbm90IHZhbGlkIGhleCBvciBhcmUgbm90IHRoZSByaWdodFxuICogbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBwYXJzZVVuaWNvZGVDb2RlKGNvZGUsIHN1cnJvZ2F0ZUNvZGUpIHtcbiAgICBjb25zdCBwYXJzZWRDb2RlID0gdmFsaWRhdGVBbmRQYXJzZUhleChjb2RlLCBlcnJvcnNfMS5FcnJvclR5cGUuTWFsZm9ybWVkVW5pY29kZSwgNCk7XG4gICAgaWYgKHN1cnJvZ2F0ZUNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBwYXJzZWRTdXJyb2dhdGVDb2RlID0gdmFsaWRhdGVBbmRQYXJzZUhleChzdXJyb2dhdGVDb2RlLCBlcnJvcnNfMS5FcnJvclR5cGUuTWFsZm9ybWVkVW5pY29kZSwgNCk7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlZENvZGUsIHBhcnNlZFN1cnJvZ2F0ZUNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZWRDb2RlKTtcbn1cbi8qKlxuICogVGVzdCBpZiB0aGUgdGV4dCBpcyBzdXJyb3VuZGVkIGJ5IGN1cmx5IGJyYWNlcyAoYHt9YCkuXG4gKiBAcGFyYW0gdGV4dCBUZXh0IHRvIGNoZWNrLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB0ZXh0IGlzIGluIHRoZSBmb3JtIGB7Kn1gLlxuICovXG5mdW5jdGlvbiBpc0N1cmx5QnJhY2VkKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC5jaGFyQXQoMCkgPT09IFwie1wiICYmIHRleHQuY2hhckF0KHRleHQubGVuZ3RoIC0gMSkgPT09IFwifVwiO1xufVxuLyoqXG4gKiBQYXJzZSBhIFVuaWNvZGUgY29kZSBwb2ludCBjaGFyYWN0ZXIgZXNjYXBlIGNvZGUuXG4gKiBAcGFyYW0gY29kZVBvaW50IEEgdW5pY29kZSBlc2NhcGUgY29kZSBwb2ludCwgaW5jbHVkaW5nIHRoZSBzdXJyb3VuZGluZyBjdXJseVxuICogYnJhY2VzLlxuICogQHJldHVybnMgVGhlIHNpbmdsZSBjaGFyYWN0ZXIgcmVwcmVzZW50ZWQgYnkgdGhlIGNvZGUuXG4gKiBAdGhyb3dzIHtTeW50YXhFcnJvcn0gSWYgdGhlIGNvZGUgaXMgbm90IHZhbGlkIGhleCBvciBkb2VzIG5vdCBoYXZlIHRoZVxuICogc3Vycm91bmRpbmcgY3VybHkgYnJhY2VzLlxuICovXG5mdW5jdGlvbiBwYXJzZVVuaWNvZGVDb2RlUG9pbnRDb2RlKGNvZGVQb2ludCkge1xuICAgIGlmICghaXNDdXJseUJyYWNlZChjb2RlUG9pbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihlcnJvcnNfMS5lcnJvck1lc3NhZ2VzLmdldChlcnJvcnNfMS5FcnJvclR5cGUuTWFsZm9ybWVkVW5pY29kZSkpO1xuICAgIH1cbiAgICBjb25zdCB3aXRob3V0QnJhY2VzID0gY29kZVBvaW50LnNsaWNlKDEsIC0xKTtcbiAgICBjb25zdCBwYXJzZWRDb2RlID0gdmFsaWRhdGVBbmRQYXJzZUhleCh3aXRob3V0QnJhY2VzLCBlcnJvcnNfMS5FcnJvclR5cGUuTWFsZm9ybWVkVW5pY29kZSk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KHBhcnNlZENvZGUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IGVyciBpbnN0YW5jZW9mIFJhbmdlRXJyb3JcbiAgICAgICAgICAgID8gbmV3IFN5bnRheEVycm9yKGVycm9yc18xLmVycm9yTWVzc2FnZXMuZ2V0KGVycm9yc18xLkVycm9yVHlwZS5Db2RlUG9pbnRMaW1pdCkpXG4gICAgICAgICAgICA6IGVycjtcbiAgICB9XG59XG4vLyBIYXZlIHRvIGdpdmUgb3ZlcmxvYWQgdGhhdCB0YWtlcyBib29sZWFuIGZvciB3aGVuIGNvbXBpbGVyIGRvZXNuJ3Qga25vdyBpZlxuLy8gdHJ1ZSBvciBmYWxzZVxuZnVuY3Rpb24gcGFyc2VPY3RhbENvZGUoY29kZSwgZXJyb3IgPSBmYWxzZSkge1xuICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoZXJyb3JzXzEuZXJyb3JNZXNzYWdlcy5nZXQoZXJyb3JzXzEuRXJyb3JUeXBlLk9jdGFsRGVwcmVjYXRpb24pKTtcbiAgICB9XG4gICAgLy8gVGhlIG9yaWdpbmFsIHJlZ2V4IG9ubHkgYWxsb3dzIGRpZ2l0cyBzbyB3ZSBkb24ndCBuZWVkIHRvIGhhdmUgYSBzdHJpY3RcbiAgICAvLyBvY3RhbCBwYXJzZXIgbGlrZSBoZXhUb0ludC4gTGVuZ3RoIGlzIG5vdCBlbmZvcmNlZCBmb3Igb2N0YWxzLlxuICAgIGNvbnN0IHBhcnNlZENvZGUgPSBwYXJzZUludChjb2RlLCA4KTtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZWRDb2RlKTtcbn1cbi8qKlxuICogTWFwIG9mIHVuZXNjYXBlZCBsZXR0ZXJzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgc3BlY2lhbCBKUyBlc2NhcGUgY2hhcmFjdGVycy5cbiAqIEludGVudGlvbmFsbHkgZG9lcyBub3QgaW5jbHVkZSBjaGFyYWN0ZXJzIHRoYXQgbWFwIHRvIHRoZW1zZWx2ZXMgbGlrZSBcIlxcJ1wiLlxuICovXG5jb25zdCBzaW5nbGVDaGFyYWN0ZXJFc2NhcGVzID0gbmV3IE1hcChbXG4gICAgW1wiYlwiLCBcIlxcYlwiXSxcbiAgICBbXCJmXCIsIFwiXFxmXCJdLFxuICAgIFtcIm5cIiwgXCJcXG5cIl0sXG4gICAgW1wiclwiLCBcIlxcclwiXSxcbiAgICBbXCJ0XCIsIFwiXFx0XCJdLFxuICAgIFtcInZcIiwgXCJcXHZcIl0sXG4gICAgW1wiMFwiLCBcIlxcMFwiXVxuXSk7XG4vKipcbiAqIFBhcnNlIGEgc2luZ2xlIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2UgYW5kIHJldHVybiB0aGUgbWF0Y2hpbmcgY2hhcmFjdGVyLlxuICogSWYgbm9uZSBpcyBtYXRjaGVkLCBkZWZhdWx0cyB0byBgY29kZWAuXG4gKiBAcGFyYW0gY29kZSBBIHNpbmdsZSBjaGFyYWN0ZXIgY29kZS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VTaW5nbGVDaGFyYWN0ZXJDb2RlKGNvZGUpIHtcbiAgICByZXR1cm4gc2luZ2xlQ2hhcmFjdGVyRXNjYXBlcy5nZXQoY29kZSkgfHwgY29kZTtcbn1cbi8qKlxuICogTWF0Y2hlcyBldmVyeSBlc2NhcGUgc2VxdWVuY2UgcG9zc2libGUsIGluY2x1ZGluZyBpbnZhbGlkIG9uZXMuXG4gKlxuICogQWxsIGNhcHR1cmUgZ3JvdXBzIChkZXNjcmliZWQgYmVsb3cpIGFyZSB1bmlxdWUgKG9ubHkgb25lIHdpbGwgbWF0Y2gpLCBleGNlcHRcbiAqIGZvciA0LCB3aGljaCBjYW4gb25seSBwb3RlbnRpYWxseSBtYXRjaCBpZiAzIGRvZXMuXG4gKlxuICogKipDYXB0dXJlIEdyb3VwczoqKlxuICogMC4gQSBzaW5nbGUgYmFja3NsYXNoXG4gKiAxLiBIZXhhZGVjaW1hbCBjb2RlXG4gKiAyLiBVbmljb2RlIGNvZGUgcG9pbnQgY29kZSB3aXRoIHN1cnJvdW5kaW5nIGN1cmx5IGJyYWNlc1xuICogMy4gVW5pY29kZSBlc2NhcGUgY29kZSB3aXRoIHN1cnJvZ2F0ZVxuICogNC4gU3Vycm9nYXRlIGNvZGVcbiAqIDUuIFVuaWNvZGUgZXNjYXBlIGNvZGUgd2l0aG91dCBzdXJyb2dhdGVcbiAqIDYuIE9jdGFsIGNvZGUgX05PVEU6IGluY2x1ZGVzIFwiMFwiLl9cbiAqIDcuIEEgc2luZ2xlIGNoYXJhY3RlciAod2lsbCBuZXZlciBiZSBcXCwgeCwgdSwgb3IgMC0zKVxuICovXG5jb25zdCBlc2NhcGVNYXRjaCA9IC9cXFxcKD86KFxcXFwpfHgoW1xcc1xcU117MCwyfSl8dShcXHtbXn1dKlxcfT8pfHUoW1xcc1xcU117NH0pXFxcXHUoW157XVtcXHNcXFNdezAsM30pfHUoW1xcc1xcU117MCw0fSl8KFswLTNdP1swLTddezEsMn0pfChbXFxzXFxTXSl8JCkvZztcbi8qKlxuICogUmVwbGFjZSByYXcgZXNjYXBlIGNoYXJhY3RlciBzdHJpbmdzIHdpdGggdGhlaXIgZXNjYXBlIGNoYXJhY3RlcnMuXG4gKiBAcGFyYW0gcmF3IEEgc3RyaW5nIHdoZXJlIGVzY2FwZSBjaGFyYWN0ZXJzIGFyZSByZXByZXNlbnRlZCBhcyByYXcgc3RyaW5nXG4gKiB2YWx1ZXMgbGlrZSBgXFwnYCByYXRoZXIgdGhhbiBgJ2AuXG4gKiBAcGFyYW0gYWxsb3dPY3RhbHMgSWYgYHRydWVgLCB3aWxsIHByb2Nlc3MgdGhlIG5vdy1kZXByZWNhdGVkIG9jdGFsIGVzY2FwZVxuICogc2VxdWVuY2VzIChpZSwgYFxcMTExYCkuXG4gKiBAcmV0dXJucyBUaGUgcHJvY2Vzc2VkIHN0cmluZywgd2l0aCBlc2NhcGUgY2hhcmFjdGVycyByZXBsYWNlZCBieSB0aGVpclxuICogcmVzcGVjdGl2ZSBhY3R1YWwgVW5pY29kZSBjaGFyYWN0ZXJzLlxuICovXG5mdW5jdGlvbiB1bnJhdyhyYXcsIGFsbG93T2N0YWxzID0gZmFsc2UpIHtcbiAgICByZXR1cm4gcmF3LnJlcGxhY2UoZXNjYXBlTWF0Y2gsIGZ1bmN0aW9uIChfLCBiYWNrc2xhc2gsIGhleCwgY29kZVBvaW50LCB1bmljb2RlV2l0aFN1cnJvZ2F0ZSwgc3Vycm9nYXRlLCB1bmljb2RlLCBvY3RhbCwgc2luZ2xlQ2hhcmFjdGVyKSB7XG4gICAgICAgIC8vIENvbXBhcmUgZ3JvdXBzIHRvIHVuZGVmaW5lZCBiZWNhdXNlIGVtcHR5IHN0cmluZ3MgbWVhbiBkaWZmZXJlbnQgZXJyb3JzXG4gICAgICAgIC8vIE90aGVyd2lzZSwgYFxcdWAgd291bGQgZmFpbCB0aGUgc2FtZSBhcyBgXFxgIHdoaWNoIGlzIHdyb25nLlxuICAgICAgICBpZiAoYmFja3NsYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlxcXFxcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUhleGFkZWNpbWFsQ29kZShoZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlUG9pbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVW5pY29kZUNvZGVQb2ludENvZGUoY29kZVBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pY29kZVdpdGhTdXJyb2dhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVW5pY29kZUNvZGUodW5pY29kZVdpdGhTdXJyb2dhdGUsIHN1cnJvZ2F0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaWNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVW5pY29kZUNvZGUodW5pY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9jdGFsID09PSBcIjBcIikge1xuICAgICAgICAgICAgcmV0dXJuIFwiXFwwXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9jdGFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU9jdGFsQ29kZShvY3RhbCwgIWFsbG93T2N0YWxzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2luZ2xlQ2hhcmFjdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVNpbmdsZUNoYXJhY3RlckNvZGUoc2luZ2xlQ2hhcmFjdGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoZXJyb3JzXzEuZXJyb3JNZXNzYWdlcy5nZXQoZXJyb3JzXzEuRXJyb3JUeXBlLkVuZE9mU3RyaW5nKSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnVucmF3ID0gdW5yYXc7XG5leHBvcnRzLmRlZmF1bHQgPSB1bnJhdztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/unraw@3.0.0/node_modules/unraw/dist/index.js\n");

/***/ })

};
;