"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lingui+core@5.3.1_@lingui+babel-plugin-lingui-macro@5.3.1_babel-plugin-macros@3.1.0_ty_09fd4f3f9e842c9ce5faa9f163a4b1ad";
exports.ids = ["vendor-chunks/@lingui+core@5.3.1_@lingui+babel-plugin-lingui-macro@5.3.1_babel-plugin-macros@3.1.0_ty_09fd4f3f9e842c9ce5faa9f163a4b1ad"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@lingui+core@5.3.1_@lingui+babel-plugin-lingui-macro@5.3.1_babel-plugin-macros@3.1.0_ty_09fd4f3f9e842c9ce5faa9f163a4b1ad/node_modules/@lingui/core/dist/index.mjs":
/*!**************************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@lingui+core@5.3.1_@lingui+babel-plugin-lingui-macro@5.3.1_babel-plugin-macros@3.1.0_ty_09fd4f3f9e842c9ce5faa9f163a4b1ad/node_modules/@lingui/core/dist/index.mjs ***!
  \**************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I18n: () => (/* binding */ I18n),\n/* harmony export */   formats: () => (/* binding */ formats),\n/* harmony export */   i18n: () => (/* binding */ i18n),\n/* harmony export */   setupI18n: () => (/* binding */ setupI18n)\n/* harmony export */ });\n/* harmony import */ var unraw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unraw */ \"(ssr)/../../node_modules/.pnpm/unraw@3.0.0/node_modules/unraw/dist/index.js\");\n/* harmony import */ var _lingui_message_utils_compileMessage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lingui/message-utils/compileMessage */ \"(ssr)/../../node_modules/.pnpm/@lingui+message-utils@5.3.1/node_modules/@lingui/message-utils/dist/compileMessage.mjs\");\n\n\n\nconst isString = (s) => typeof s === \"string\";\nconst isFunction = (f) => typeof f === \"function\";\n\nconst cache = /* @__PURE__ */ new Map();\nconst defaultLocale = \"en\";\nfunction normalizeLocales(locales) {\n  const out = Array.isArray(locales) ? locales : [locales];\n  return [...out, defaultLocale];\n}\nfunction date(locales, value, format) {\n  const _locales = normalizeLocales(locales);\n  if (!format) {\n    format = \"default\";\n  }\n  let o;\n  if (typeof format === \"string\") {\n    o = {\n      day: \"numeric\",\n      month: \"short\",\n      year: \"numeric\"\n    };\n    switch (format) {\n      case \"full\":\n        o.weekday = \"long\";\n      case \"long\":\n        o.month = \"long\";\n        break;\n      case \"short\":\n        o.month = \"numeric\";\n        break;\n    }\n  } else {\n    o = format;\n  }\n  const formatter = getMemoized(\n    () => cacheKey(\"date\", _locales, format),\n    () => new Intl.DateTimeFormat(_locales, o)\n  );\n  return formatter.format(isString(value) ? new Date(value) : value);\n}\nfunction time(locales, value, format) {\n  let o;\n  if (!format) {\n    format = \"default\";\n  }\n  if (typeof format === \"string\") {\n    o = {\n      second: \"numeric\",\n      minute: \"numeric\",\n      hour: \"numeric\"\n    };\n    switch (format) {\n      case \"full\":\n      case \"long\":\n        o.timeZoneName = \"short\";\n        break;\n      case \"short\":\n        delete o.second;\n    }\n  } else {\n    o = format;\n  }\n  return date(locales, value, o);\n}\nfunction number(locales, value, format) {\n  const _locales = normalizeLocales(locales);\n  const formatter = getMemoized(\n    () => cacheKey(\"number\", _locales, format),\n    () => new Intl.NumberFormat(_locales, format)\n  );\n  return formatter.format(value);\n}\nfunction plural(locales, ordinal, value, { offset = 0, ...rules }) {\n  const _locales = normalizeLocales(locales);\n  const plurals = ordinal ? getMemoized(\n    () => cacheKey(\"plural-ordinal\", _locales),\n    () => new Intl.PluralRules(_locales, { type: \"ordinal\" })\n  ) : getMemoized(\n    () => cacheKey(\"plural-cardinal\", _locales),\n    () => new Intl.PluralRules(_locales, { type: \"cardinal\" })\n  );\n  return rules[value] ?? rules[plurals.select(value - offset)] ?? rules.other;\n}\nfunction getMemoized(getKey, construct) {\n  const key = getKey();\n  let formatter = cache.get(key);\n  if (!formatter) {\n    formatter = construct();\n    cache.set(key, formatter);\n  }\n  return formatter;\n}\nfunction cacheKey(type, locales, options) {\n  const localeKey = locales.join(\"-\");\n  return `${type}-${localeKey}-${JSON.stringify(options)}`;\n}\n\nconst formats = {\n  __proto__: null,\n  date: date,\n  defaultLocale: defaultLocale,\n  number: number,\n  plural: plural,\n  time: time\n};\n\nconst UNICODE_REGEX = /\\\\u[a-fA-F0-9]{4}|\\\\x[a-fA-F0-9]{2}/;\nconst OCTOTHORPE_PH = \"%__lingui_octothorpe__%\";\nconst getDefaultFormats = (locale, passedLocales, formats = {}) => {\n  const locales = passedLocales || locale;\n  const style = (format) => {\n    if (typeof format === \"object\")\n      return format;\n    return formats[format];\n  };\n  const replaceOctothorpe = (value, message) => {\n    const numberFormat = Object.keys(formats).length ? style(\"number\") : void 0;\n    const valueStr = number(locales, value, numberFormat);\n    return message.replace(new RegExp(OCTOTHORPE_PH, \"g\"), valueStr);\n  };\n  return {\n    plural: (value, cases) => {\n      const { offset = 0 } = cases;\n      const message = plural(locales, false, value, cases);\n      return replaceOctothorpe(value - offset, message);\n    },\n    selectordinal: (value, cases) => {\n      const { offset = 0 } = cases;\n      const message = plural(locales, true, value, cases);\n      return replaceOctothorpe(value - offset, message);\n    },\n    select: selectFormatter,\n    number: (value, format) => number(\n      locales,\n      value,\n      style(format) || { style: format }\n    ),\n    date: (value, format) => date(locales, value, style(format) || format),\n    time: (value, format) => time(locales, value, style(format) || format)\n  };\n};\nconst selectFormatter = (value, rules) => rules[value] ?? rules.other;\nfunction interpolate(translation, locale, locales) {\n  return (values = {}, formats) => {\n    const formatters = getDefaultFormats(locale, locales, formats);\n    const formatMessage = (tokens, replaceOctothorpe = false) => {\n      if (!Array.isArray(tokens))\n        return tokens;\n      return tokens.reduce((message, token) => {\n        if (token === \"#\" && replaceOctothorpe) {\n          return message + OCTOTHORPE_PH;\n        }\n        if (isString(token)) {\n          return message + token;\n        }\n        const [name, type, format] = token;\n        let interpolatedFormat = {};\n        if (type === \"plural\" || type === \"selectordinal\" || type === \"select\") {\n          Object.entries(format).forEach(\n            ([key, value2]) => {\n              interpolatedFormat[key] = formatMessage(\n                value2,\n                type === \"plural\" || type === \"selectordinal\"\n              );\n            }\n          );\n        } else {\n          interpolatedFormat = format;\n        }\n        let value;\n        if (type) {\n          const formatter = formatters[type];\n          value = formatter(values[name], interpolatedFormat);\n        } else {\n          value = values[name];\n        }\n        if (value == null) {\n          return message;\n        }\n        return message + value;\n      }, \"\");\n    };\n    const result = formatMessage(translation);\n    if (isString(result) && UNICODE_REGEX.test(result)) {\n      return (0,unraw__WEBPACK_IMPORTED_MODULE_0__.unraw)(result);\n    }\n    if (isString(result))\n      return result;\n    return result ? String(result) : \"\";\n  };\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass EventEmitter {\n  constructor() {\n    __publicField$1(this, \"_events\", {});\n  }\n  on(event, listener) {\n    var _a;\n    (_a = this._events)[event] ?? (_a[event] = []);\n    this._events[event].push(listener);\n    return () => this.removeListener(event, listener);\n  }\n  removeListener(event, listener) {\n    const maybeListeners = this._getListeners(event);\n    if (!maybeListeners)\n      return;\n    const index = maybeListeners.indexOf(listener);\n    if (~index)\n      maybeListeners.splice(index, 1);\n  }\n  emit(event, ...args) {\n    const maybeListeners = this._getListeners(event);\n    if (!maybeListeners)\n      return;\n    maybeListeners.map((listener) => listener.apply(this, args));\n  }\n  _getListeners(event) {\n    const maybeListeners = this._events[event];\n    return Array.isArray(maybeListeners) ? maybeListeners : false;\n  }\n}\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass I18n extends EventEmitter {\n  constructor(params) {\n    super();\n    __publicField(this, \"_locale\", \"\");\n    __publicField(this, \"_locales\");\n    __publicField(this, \"_localeData\", {});\n    __publicField(this, \"_messages\", {});\n    __publicField(this, \"_missing\");\n    __publicField(this, \"_messageCompiler\");\n    /**\n     * Alias for {@see I18n._}\n     */\n    __publicField(this, \"t\", this._.bind(this));\n    if (true) {\n      this.setMessagesCompiler(_lingui_message_utils_compileMessage__WEBPACK_IMPORTED_MODULE_1__.compileMessage);\n    }\n    if (params.missing != null)\n      this._missing = params.missing;\n    if (params.messages != null)\n      this.load(params.messages);\n    if (params.localeData != null)\n      this.loadLocaleData(params.localeData);\n    if (typeof params.locale === \"string\" || params.locales) {\n      this.activate(params.locale ?? defaultLocale, params.locales);\n    }\n  }\n  get locale() {\n    return this._locale;\n  }\n  get locales() {\n    return this._locales;\n  }\n  get messages() {\n    return this._messages[this._locale] ?? {};\n  }\n  /**\n   * @deprecated this has no effect. Please remove this from the code. Deprecated in v4\n   */\n  get localeData() {\n    return this._localeData[this._locale] ?? {};\n  }\n  _loadLocaleData(locale, localeData) {\n    const maybeLocaleData = this._localeData[locale];\n    if (!maybeLocaleData) {\n      this._localeData[locale] = localeData;\n    } else {\n      Object.assign(maybeLocaleData, localeData);\n    }\n  }\n  /**\n   * Registers a `MessageCompiler` to enable the use of uncompiled catalogs at runtime.\n   *\n   * In production builds, the `MessageCompiler` is typically excluded to reduce bundle size.\n   * By default, message catalogs should be precompiled during the build process. However,\n   * if you need to compile catalogs at runtime, you can use this method to set a message compiler.\n   *\n   * Example usage:\n   *\n   * ```ts\n   * import { compileMessage } from \"@lingui/message-utils/compileMessage\";\n   *\n   * i18n.setMessagesCompiler(compileMessage);\n   * ```\n   */\n  setMessagesCompiler(compiler) {\n    this._messageCompiler = compiler;\n    return this;\n  }\n  /**\n   * @deprecated Plurals automatically used from Intl.PluralRules you can safely remove this call. Deprecated in v4\n   */\n  loadLocaleData(localeOrAllData, localeData) {\n    if (typeof localeOrAllData === \"string\") {\n      this._loadLocaleData(localeOrAllData, localeData);\n    } else {\n      Object.keys(localeOrAllData).forEach(\n        (locale) => this._loadLocaleData(locale, localeOrAllData[locale])\n      );\n    }\n    this.emit(\"change\");\n  }\n  _load(locale, messages) {\n    const maybeMessages = this._messages[locale];\n    if (!maybeMessages) {\n      this._messages[locale] = messages;\n    } else {\n      Object.assign(maybeMessages, messages);\n    }\n  }\n  load(localeOrMessages, messages) {\n    if (typeof localeOrMessages == \"string\" && typeof messages === \"object\") {\n      this._load(localeOrMessages, messages);\n    } else {\n      Object.entries(localeOrMessages).forEach(\n        ([locale, messages2]) => this._load(locale, messages2)\n      );\n    }\n    this.emit(\"change\");\n  }\n  /**\n   * @param options {@link LoadAndActivateOptions}\n   */\n  loadAndActivate({ locale, locales, messages }) {\n    this._locale = locale;\n    this._locales = locales || void 0;\n    this._messages[this._locale] = messages;\n    this.emit(\"change\");\n  }\n  activate(locale, locales) {\n    if (true) {\n      if (!this._messages[locale]) {\n        console.warn(`Messages for locale \"${locale}\" not loaded.`);\n      }\n    }\n    this._locale = locale;\n    this._locales = locales;\n    this.emit(\"change\");\n  }\n  _(id, values, options) {\n    if (!this.locale) {\n      throw new Error(\n        \"Lingui: Attempted to call a translation function without setting a locale.\\nMake sure to call `i18n.activate(locale)` before using Lingui functions.\\nThis issue may also occur due to a race condition in your initialization logic.\"\n      );\n    }\n    let message = options?.message;\n    if (!id) {\n      id = \"\";\n    }\n    if (!isString(id)) {\n      values = id.values || values;\n      message = id.message;\n      id = id.id;\n    }\n    const messageForId = this.messages[id];\n    const messageMissing = messageForId === void 0;\n    const missing = this._missing;\n    if (missing && messageMissing) {\n      return isFunction(missing) ? missing(this._locale, id) : missing;\n    }\n    if (messageMissing) {\n      this.emit(\"missing\", { id, locale: this._locale });\n    }\n    let translation = messageForId || message || id;\n    if (isString(translation)) {\n      if (this._messageCompiler) {\n        translation = this._messageCompiler(translation);\n      } else {\n        console.warn(`Uncompiled message detected! Message:\n\n> ${translation}\n\nThat means you use raw catalog or your catalog doesn't have a translation for the message and fallback was used.\nICU features such as interpolation and plurals will not work properly for that message. \n\nPlease compile your catalog first. \n`);\n      }\n    }\n    if (isString(translation) && UNICODE_REGEX.test(translation))\n      return JSON.parse(`\"${translation}\"`);\n    if (isString(translation))\n      return translation;\n    return interpolate(\n      translation,\n      this._locale,\n      this._locales\n    )(values, options?.formats);\n  }\n  date(value, format) {\n    return date(this._locales || this._locale, value, format);\n  }\n  number(value, format) {\n    return number(this._locales || this._locale, value, format);\n  }\n}\nfunction setupI18n(params = {}) {\n  return new I18n(params);\n}\n\nconst i18n = setupI18n();\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BsaW5ndWkrY29yZUA1LjMuMV9AbGluZ3VpK2JhYmVsLXBsdWdpbi1saW5ndWktbWFjcm9ANS4zLjFfYmFiZWwtcGx1Z2luLW1hY3Jvc0AzLjEuMF90eV8wOWZkNGYzZjllODQyYzljZTVmYWE5ZjE2M2E0YjFhZC9ub2RlX21vZHVsZXMvQGxpbmd1aS9jb3JlL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE4QjtBQUN3Qzs7QUFFdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHNCQUFzQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUJBQWlCO0FBQzVEO0FBQ0E7QUFDQSwyQ0FBMkMsa0JBQWtCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUssR0FBRyxVQUFVLEdBQUcsd0JBQXdCO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLEVBQUUsZ0JBQWdCLEVBQUU7QUFDMUQ7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0Q0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRkFBa0YsNkRBQTZEO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QywrQkFBK0IsZ0ZBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwwQkFBMEI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBOztBQUUwQyIsInNvdXJjZXMiOlsiL1VzZXJzL2FydGVtLnN0ZXBhbm92L2Zyb250ZW5kLW1vbm8vbm9kZV9tb2R1bGVzLy5wbnBtL0BsaW5ndWkrY29yZUA1LjMuMV9AbGluZ3VpK2JhYmVsLXBsdWdpbi1saW5ndWktbWFjcm9ANS4zLjFfYmFiZWwtcGx1Z2luLW1hY3Jvc0AzLjEuMF90eV8wOWZkNGYzZjllODQyYzljZTVmYWE5ZjE2M2E0YjFhZC9ub2RlX21vZHVsZXMvQGxpbmd1aS9jb3JlL2Rpc3QvaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVucmF3IH0gZnJvbSAndW5yYXcnO1xuaW1wb3J0IHsgY29tcGlsZU1lc3NhZ2UgfSBmcm9tICdAbGluZ3VpL21lc3NhZ2UtdXRpbHMvY29tcGlsZU1lc3NhZ2UnO1xuXG5jb25zdCBpc1N0cmluZyA9IChzKSA9PiB0eXBlb2YgcyA9PT0gXCJzdHJpbmdcIjtcbmNvbnN0IGlzRnVuY3Rpb24gPSAoZikgPT4gdHlwZW9mIGYgPT09IFwiZnVuY3Rpb25cIjtcblxuY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuY29uc3QgZGVmYXVsdExvY2FsZSA9IFwiZW5cIjtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZXMobG9jYWxlcykge1xuICBjb25zdCBvdXQgPSBBcnJheS5pc0FycmF5KGxvY2FsZXMpID8gbG9jYWxlcyA6IFtsb2NhbGVzXTtcbiAgcmV0dXJuIFsuLi5vdXQsIGRlZmF1bHRMb2NhbGVdO1xufVxuZnVuY3Rpb24gZGF0ZShsb2NhbGVzLCB2YWx1ZSwgZm9ybWF0KSB7XG4gIGNvbnN0IF9sb2NhbGVzID0gbm9ybWFsaXplTG9jYWxlcyhsb2NhbGVzKTtcbiAgaWYgKCFmb3JtYXQpIHtcbiAgICBmb3JtYXQgPSBcImRlZmF1bHRcIjtcbiAgfVxuICBsZXQgbztcbiAgaWYgKHR5cGVvZiBmb3JtYXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBvID0ge1xuICAgICAgZGF5OiBcIm51bWVyaWNcIixcbiAgICAgIG1vbnRoOiBcInNob3J0XCIsXG4gICAgICB5ZWFyOiBcIm51bWVyaWNcIlxuICAgIH07XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgIGNhc2UgXCJmdWxsXCI6XG4gICAgICAgIG8ud2Vla2RheSA9IFwibG9uZ1wiO1xuICAgICAgY2FzZSBcImxvbmdcIjpcbiAgICAgICAgby5tb250aCA9IFwibG9uZ1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgICBvLm1vbnRoID0gXCJudW1lcmljXCI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvID0gZm9ybWF0O1xuICB9XG4gIGNvbnN0IGZvcm1hdHRlciA9IGdldE1lbW9pemVkKFxuICAgICgpID0+IGNhY2hlS2V5KFwiZGF0ZVwiLCBfbG9jYWxlcywgZm9ybWF0KSxcbiAgICAoKSA9PiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChfbG9jYWxlcywgbylcbiAgKTtcbiAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQoaXNTdHJpbmcodmFsdWUpID8gbmV3IERhdGUodmFsdWUpIDogdmFsdWUpO1xufVxuZnVuY3Rpb24gdGltZShsb2NhbGVzLCB2YWx1ZSwgZm9ybWF0KSB7XG4gIGxldCBvO1xuICBpZiAoIWZvcm1hdCkge1xuICAgIGZvcm1hdCA9IFwiZGVmYXVsdFwiO1xuICB9XG4gIGlmICh0eXBlb2YgZm9ybWF0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgbyA9IHtcbiAgICAgIHNlY29uZDogXCJudW1lcmljXCIsXG4gICAgICBtaW51dGU6IFwibnVtZXJpY1wiLFxuICAgICAgaG91cjogXCJudW1lcmljXCJcbiAgICB9O1xuICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICBjYXNlIFwiZnVsbFwiOlxuICAgICAgY2FzZSBcImxvbmdcIjpcbiAgICAgICAgby50aW1lWm9uZU5hbWUgPSBcInNob3J0XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNob3J0XCI6XG4gICAgICAgIGRlbGV0ZSBvLnNlY29uZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbyA9IGZvcm1hdDtcbiAgfVxuICByZXR1cm4gZGF0ZShsb2NhbGVzLCB2YWx1ZSwgbyk7XG59XG5mdW5jdGlvbiBudW1iZXIobG9jYWxlcywgdmFsdWUsIGZvcm1hdCkge1xuICBjb25zdCBfbG9jYWxlcyA9IG5vcm1hbGl6ZUxvY2FsZXMobG9jYWxlcyk7XG4gIGNvbnN0IGZvcm1hdHRlciA9IGdldE1lbW9pemVkKFxuICAgICgpID0+IGNhY2hlS2V5KFwibnVtYmVyXCIsIF9sb2NhbGVzLCBmb3JtYXQpLFxuICAgICgpID0+IG5ldyBJbnRsLk51bWJlckZvcm1hdChfbG9jYWxlcywgZm9ybWF0KVxuICApO1xuICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBwbHVyYWwobG9jYWxlcywgb3JkaW5hbCwgdmFsdWUsIHsgb2Zmc2V0ID0gMCwgLi4ucnVsZXMgfSkge1xuICBjb25zdCBfbG9jYWxlcyA9IG5vcm1hbGl6ZUxvY2FsZXMobG9jYWxlcyk7XG4gIGNvbnN0IHBsdXJhbHMgPSBvcmRpbmFsID8gZ2V0TWVtb2l6ZWQoXG4gICAgKCkgPT4gY2FjaGVLZXkoXCJwbHVyYWwtb3JkaW5hbFwiLCBfbG9jYWxlcyksXG4gICAgKCkgPT4gbmV3IEludGwuUGx1cmFsUnVsZXMoX2xvY2FsZXMsIHsgdHlwZTogXCJvcmRpbmFsXCIgfSlcbiAgKSA6IGdldE1lbW9pemVkKFxuICAgICgpID0+IGNhY2hlS2V5KFwicGx1cmFsLWNhcmRpbmFsXCIsIF9sb2NhbGVzKSxcbiAgICAoKSA9PiBuZXcgSW50bC5QbHVyYWxSdWxlcyhfbG9jYWxlcywgeyB0eXBlOiBcImNhcmRpbmFsXCIgfSlcbiAgKTtcbiAgcmV0dXJuIHJ1bGVzW3ZhbHVlXSA/PyBydWxlc1twbHVyYWxzLnNlbGVjdCh2YWx1ZSAtIG9mZnNldCldID8/IHJ1bGVzLm90aGVyO1xufVxuZnVuY3Rpb24gZ2V0TWVtb2l6ZWQoZ2V0S2V5LCBjb25zdHJ1Y3QpIHtcbiAgY29uc3Qga2V5ID0gZ2V0S2V5KCk7XG4gIGxldCBmb3JtYXR0ZXIgPSBjYWNoZS5nZXQoa2V5KTtcbiAgaWYgKCFmb3JtYXR0ZXIpIHtcbiAgICBmb3JtYXR0ZXIgPSBjb25zdHJ1Y3QoKTtcbiAgICBjYWNoZS5zZXQoa2V5LCBmb3JtYXR0ZXIpO1xuICB9XG4gIHJldHVybiBmb3JtYXR0ZXI7XG59XG5mdW5jdGlvbiBjYWNoZUtleSh0eXBlLCBsb2NhbGVzLCBvcHRpb25zKSB7XG4gIGNvbnN0IGxvY2FsZUtleSA9IGxvY2FsZXMuam9pbihcIi1cIik7XG4gIHJldHVybiBgJHt0eXBlfS0ke2xvY2FsZUtleX0tJHtKU09OLnN0cmluZ2lmeShvcHRpb25zKX1gO1xufVxuXG5jb25zdCBmb3JtYXRzID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIGRhdGU6IGRhdGUsXG4gIGRlZmF1bHRMb2NhbGU6IGRlZmF1bHRMb2NhbGUsXG4gIG51bWJlcjogbnVtYmVyLFxuICBwbHVyYWw6IHBsdXJhbCxcbiAgdGltZTogdGltZVxufTtcblxuY29uc3QgVU5JQ09ERV9SRUdFWCA9IC9cXFxcdVthLWZBLUYwLTldezR9fFxcXFx4W2EtZkEtRjAtOV17Mn0vO1xuY29uc3QgT0NUT1RIT1JQRV9QSCA9IFwiJV9fbGluZ3VpX29jdG90aG9ycGVfXyVcIjtcbmNvbnN0IGdldERlZmF1bHRGb3JtYXRzID0gKGxvY2FsZSwgcGFzc2VkTG9jYWxlcywgZm9ybWF0cyA9IHt9KSA9PiB7XG4gIGNvbnN0IGxvY2FsZXMgPSBwYXNzZWRMb2NhbGVzIHx8IGxvY2FsZTtcbiAgY29uc3Qgc3R5bGUgPSAoZm9ybWF0KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gZm9ybWF0O1xuICAgIHJldHVybiBmb3JtYXRzW2Zvcm1hdF07XG4gIH07XG4gIGNvbnN0IHJlcGxhY2VPY3RvdGhvcnBlID0gKHZhbHVlLCBtZXNzYWdlKSA9PiB7XG4gICAgY29uc3QgbnVtYmVyRm9ybWF0ID0gT2JqZWN0LmtleXMoZm9ybWF0cykubGVuZ3RoID8gc3R5bGUoXCJudW1iZXJcIikgOiB2b2lkIDA7XG4gICAgY29uc3QgdmFsdWVTdHIgPSBudW1iZXIobG9jYWxlcywgdmFsdWUsIG51bWJlckZvcm1hdCk7XG4gICAgcmV0dXJuIG1lc3NhZ2UucmVwbGFjZShuZXcgUmVnRXhwKE9DVE9USE9SUEVfUEgsIFwiZ1wiKSwgdmFsdWVTdHIpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHBsdXJhbDogKHZhbHVlLCBjYXNlcykgPT4ge1xuICAgICAgY29uc3QgeyBvZmZzZXQgPSAwIH0gPSBjYXNlcztcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBwbHVyYWwobG9jYWxlcywgZmFsc2UsIHZhbHVlLCBjYXNlcyk7XG4gICAgICByZXR1cm4gcmVwbGFjZU9jdG90aG9ycGUodmFsdWUgLSBvZmZzZXQsIG1lc3NhZ2UpO1xuICAgIH0sXG4gICAgc2VsZWN0b3JkaW5hbDogKHZhbHVlLCBjYXNlcykgPT4ge1xuICAgICAgY29uc3QgeyBvZmZzZXQgPSAwIH0gPSBjYXNlcztcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBwbHVyYWwobG9jYWxlcywgdHJ1ZSwgdmFsdWUsIGNhc2VzKTtcbiAgICAgIHJldHVybiByZXBsYWNlT2N0b3Rob3JwZSh2YWx1ZSAtIG9mZnNldCwgbWVzc2FnZSk7XG4gICAgfSxcbiAgICBzZWxlY3Q6IHNlbGVjdEZvcm1hdHRlcixcbiAgICBudW1iZXI6ICh2YWx1ZSwgZm9ybWF0KSA9PiBudW1iZXIoXG4gICAgICBsb2NhbGVzLFxuICAgICAgdmFsdWUsXG4gICAgICBzdHlsZShmb3JtYXQpIHx8IHsgc3R5bGU6IGZvcm1hdCB9XG4gICAgKSxcbiAgICBkYXRlOiAodmFsdWUsIGZvcm1hdCkgPT4gZGF0ZShsb2NhbGVzLCB2YWx1ZSwgc3R5bGUoZm9ybWF0KSB8fCBmb3JtYXQpLFxuICAgIHRpbWU6ICh2YWx1ZSwgZm9ybWF0KSA9PiB0aW1lKGxvY2FsZXMsIHZhbHVlLCBzdHlsZShmb3JtYXQpIHx8IGZvcm1hdClcbiAgfTtcbn07XG5jb25zdCBzZWxlY3RGb3JtYXR0ZXIgPSAodmFsdWUsIHJ1bGVzKSA9PiBydWxlc1t2YWx1ZV0gPz8gcnVsZXMub3RoZXI7XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh0cmFuc2xhdGlvbiwgbG9jYWxlLCBsb2NhbGVzKSB7XG4gIHJldHVybiAodmFsdWVzID0ge30sIGZvcm1hdHMpID0+IHtcbiAgICBjb25zdCBmb3JtYXR0ZXJzID0gZ2V0RGVmYXVsdEZvcm1hdHMobG9jYWxlLCBsb2NhbGVzLCBmb3JtYXRzKTtcbiAgICBjb25zdCBmb3JtYXRNZXNzYWdlID0gKHRva2VucywgcmVwbGFjZU9jdG90aG9ycGUgPSBmYWxzZSkgPT4ge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRva2VucykpXG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICByZXR1cm4gdG9rZW5zLnJlZHVjZSgobWVzc2FnZSwgdG9rZW4pID0+IHtcbiAgICAgICAgaWYgKHRva2VuID09PSBcIiNcIiAmJiByZXBsYWNlT2N0b3Rob3JwZSkge1xuICAgICAgICAgIHJldHVybiBtZXNzYWdlICsgT0NUT1RIT1JQRV9QSDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpbmcodG9rZW4pKSB7XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2UgKyB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbbmFtZSwgdHlwZSwgZm9ybWF0XSA9IHRva2VuO1xuICAgICAgICBsZXQgaW50ZXJwb2xhdGVkRm9ybWF0ID0ge307XG4gICAgICAgIGlmICh0eXBlID09PSBcInBsdXJhbFwiIHx8IHR5cGUgPT09IFwic2VsZWN0b3JkaW5hbFwiIHx8IHR5cGUgPT09IFwic2VsZWN0XCIpIHtcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhmb3JtYXQpLmZvckVhY2goXG4gICAgICAgICAgICAoW2tleSwgdmFsdWUyXSkgPT4ge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWRGb3JtYXRba2V5XSA9IGZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgICAgICAgdmFsdWUyLFxuICAgICAgICAgICAgICAgIHR5cGUgPT09IFwicGx1cmFsXCIgfHwgdHlwZSA9PT0gXCJzZWxlY3RvcmRpbmFsXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludGVycG9sYXRlZEZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gZm9ybWF0dGVyc1t0eXBlXTtcbiAgICAgICAgICB2YWx1ZSA9IGZvcm1hdHRlcih2YWx1ZXNbbmFtZV0sIGludGVycG9sYXRlZEZvcm1hdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZSArIHZhbHVlO1xuICAgICAgfSwgXCJcIik7XG4gICAgfTtcbiAgICBjb25zdCByZXN1bHQgPSBmb3JtYXRNZXNzYWdlKHRyYW5zbGF0aW9uKTtcbiAgICBpZiAoaXNTdHJpbmcocmVzdWx0KSAmJiBVTklDT0RFX1JFR0VYLnRlc3QocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHVucmF3KHJlc3VsdCk7XG4gICAgfVxuICAgIGlmIChpc1N0cmluZyhyZXN1bHQpKVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0ID8gU3RyaW5nKHJlc3VsdCkgOiBcIlwiO1xuICB9O1xufVxuXG52YXIgX19kZWZQcm9wJDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDEob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wJDEob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY2xhc3MgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiX2V2ZW50c1wiLCB7fSk7XG4gIH1cbiAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHRoaXMuX2V2ZW50cylbZXZlbnRdID8/IChfYVtldmVudF0gPSBbXSk7XG4gICAgdGhpcy5fZXZlbnRzW2V2ZW50XS5wdXNoKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICB9XG4gIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IG1heWJlTGlzdGVuZXJzID0gdGhpcy5fZ2V0TGlzdGVuZXJzKGV2ZW50KTtcbiAgICBpZiAoIW1heWJlTGlzdGVuZXJzKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGluZGV4ID0gbWF5YmVMaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgaWYgKH5pbmRleClcbiAgICAgIG1heWJlTGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbiAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgIGNvbnN0IG1heWJlTGlzdGVuZXJzID0gdGhpcy5fZ2V0TGlzdGVuZXJzKGV2ZW50KTtcbiAgICBpZiAoIW1heWJlTGlzdGVuZXJzKVxuICAgICAgcmV0dXJuO1xuICAgIG1heWJlTGlzdGVuZXJzLm1hcCgobGlzdGVuZXIpID0+IGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgfVxuICBfZ2V0TGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgY29uc3QgbWF5YmVMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG1heWJlTGlzdGVuZXJzKSA/IG1heWJlTGlzdGVuZXJzIDogZmFsc2U7XG4gIH1cbn1cblxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY2xhc3MgSTE4biBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9sb2NhbGVcIiwgXCJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9sb2NhbGVzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbG9jYWxlRGF0YVwiLCB7fSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9tZXNzYWdlc1wiLCB7fSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9taXNzaW5nXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbWVzc2FnZUNvbXBpbGVyXCIpO1xuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB7QHNlZSBJMThuLl99XG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRcIiwgdGhpcy5fLmJpbmQodGhpcykpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHRoaXMuc2V0TWVzc2FnZXNDb21waWxlcihjb21waWxlTWVzc2FnZSk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMubWlzc2luZyAhPSBudWxsKVxuICAgICAgdGhpcy5fbWlzc2luZyA9IHBhcmFtcy5taXNzaW5nO1xuICAgIGlmIChwYXJhbXMubWVzc2FnZXMgIT0gbnVsbClcbiAgICAgIHRoaXMubG9hZChwYXJhbXMubWVzc2FnZXMpO1xuICAgIGlmIChwYXJhbXMubG9jYWxlRGF0YSAhPSBudWxsKVxuICAgICAgdGhpcy5sb2FkTG9jYWxlRGF0YShwYXJhbXMubG9jYWxlRGF0YSk7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMubG9jYWxlID09PSBcInN0cmluZ1wiIHx8IHBhcmFtcy5sb2NhbGVzKSB7XG4gICAgICB0aGlzLmFjdGl2YXRlKHBhcmFtcy5sb2NhbGUgPz8gZGVmYXVsdExvY2FsZSwgcGFyYW1zLmxvY2FsZXMpO1xuICAgIH1cbiAgfVxuICBnZXQgbG9jYWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG4gIH1cbiAgZ2V0IGxvY2FsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsZXM7XG4gIH1cbiAgZ2V0IG1lc3NhZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9tZXNzYWdlc1t0aGlzLl9sb2NhbGVdID8/IHt9O1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB0aGlzIGhhcyBubyBlZmZlY3QuIFBsZWFzZSByZW1vdmUgdGhpcyBmcm9tIHRoZSBjb2RlLiBEZXByZWNhdGVkIGluIHY0XG4gICAqL1xuICBnZXQgbG9jYWxlRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxlRGF0YVt0aGlzLl9sb2NhbGVdID8/IHt9O1xuICB9XG4gIF9sb2FkTG9jYWxlRGF0YShsb2NhbGUsIGxvY2FsZURhdGEpIHtcbiAgICBjb25zdCBtYXliZUxvY2FsZURhdGEgPSB0aGlzLl9sb2NhbGVEYXRhW2xvY2FsZV07XG4gICAgaWYgKCFtYXliZUxvY2FsZURhdGEpIHtcbiAgICAgIHRoaXMuX2xvY2FsZURhdGFbbG9jYWxlXSA9IGxvY2FsZURhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5hc3NpZ24obWF5YmVMb2NhbGVEYXRhLCBsb2NhbGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGBNZXNzYWdlQ29tcGlsZXJgIHRvIGVuYWJsZSB0aGUgdXNlIG9mIHVuY29tcGlsZWQgY2F0YWxvZ3MgYXQgcnVudGltZS5cbiAgICpcbiAgICogSW4gcHJvZHVjdGlvbiBidWlsZHMsIHRoZSBgTWVzc2FnZUNvbXBpbGVyYCBpcyB0eXBpY2FsbHkgZXhjbHVkZWQgdG8gcmVkdWNlIGJ1bmRsZSBzaXplLlxuICAgKiBCeSBkZWZhdWx0LCBtZXNzYWdlIGNhdGFsb2dzIHNob3VsZCBiZSBwcmVjb21waWxlZCBkdXJpbmcgdGhlIGJ1aWxkIHByb2Nlc3MuIEhvd2V2ZXIsXG4gICAqIGlmIHlvdSBuZWVkIHRvIGNvbXBpbGUgY2F0YWxvZ3MgYXQgcnVudGltZSwgeW91IGNhbiB1c2UgdGhpcyBtZXRob2QgdG8gc2V0IGEgbWVzc2FnZSBjb21waWxlci5cbiAgICpcbiAgICogRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IHsgY29tcGlsZU1lc3NhZ2UgfSBmcm9tIFwiQGxpbmd1aS9tZXNzYWdlLXV0aWxzL2NvbXBpbGVNZXNzYWdlXCI7XG4gICAqXG4gICAqIGkxOG4uc2V0TWVzc2FnZXNDb21waWxlcihjb21waWxlTWVzc2FnZSk7XG4gICAqIGBgYFxuICAgKi9cbiAgc2V0TWVzc2FnZXNDb21waWxlcihjb21waWxlcikge1xuICAgIHRoaXMuX21lc3NhZ2VDb21waWxlciA9IGNvbXBpbGVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBQbHVyYWxzIGF1dG9tYXRpY2FsbHkgdXNlZCBmcm9tIEludGwuUGx1cmFsUnVsZXMgeW91IGNhbiBzYWZlbHkgcmVtb3ZlIHRoaXMgY2FsbC4gRGVwcmVjYXRlZCBpbiB2NFxuICAgKi9cbiAgbG9hZExvY2FsZURhdGEobG9jYWxlT3JBbGxEYXRhLCBsb2NhbGVEYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhbGVPckFsbERhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMuX2xvYWRMb2NhbGVEYXRhKGxvY2FsZU9yQWxsRGF0YSwgbG9jYWxlRGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5rZXlzKGxvY2FsZU9yQWxsRGF0YSkuZm9yRWFjaChcbiAgICAgICAgKGxvY2FsZSkgPT4gdGhpcy5fbG9hZExvY2FsZURhdGEobG9jYWxlLCBsb2NhbGVPckFsbERhdGFbbG9jYWxlXSlcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuZW1pdChcImNoYW5nZVwiKTtcbiAgfVxuICBfbG9hZChsb2NhbGUsIG1lc3NhZ2VzKSB7XG4gICAgY29uc3QgbWF5YmVNZXNzYWdlcyA9IHRoaXMuX21lc3NhZ2VzW2xvY2FsZV07XG4gICAgaWYgKCFtYXliZU1lc3NhZ2VzKSB7XG4gICAgICB0aGlzLl9tZXNzYWdlc1tsb2NhbGVdID0gbWVzc2FnZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5hc3NpZ24obWF5YmVNZXNzYWdlcywgbWVzc2FnZXMpO1xuICAgIH1cbiAgfVxuICBsb2FkKGxvY2FsZU9yTWVzc2FnZXMsIG1lc3NhZ2VzKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhbGVPck1lc3NhZ2VzID09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG1lc3NhZ2VzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aGlzLl9sb2FkKGxvY2FsZU9yTWVzc2FnZXMsIG1lc3NhZ2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmVudHJpZXMobG9jYWxlT3JNZXNzYWdlcykuZm9yRWFjaChcbiAgICAgICAgKFtsb2NhbGUsIG1lc3NhZ2VzMl0pID0+IHRoaXMuX2xvYWQobG9jYWxlLCBtZXNzYWdlczIpXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIik7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIHtAbGluayBMb2FkQW5kQWN0aXZhdGVPcHRpb25zfVxuICAgKi9cbiAgbG9hZEFuZEFjdGl2YXRlKHsgbG9jYWxlLCBsb2NhbGVzLCBtZXNzYWdlcyB9KSB7XG4gICAgdGhpcy5fbG9jYWxlID0gbG9jYWxlO1xuICAgIHRoaXMuX2xvY2FsZXMgPSBsb2NhbGVzIHx8IHZvaWQgMDtcbiAgICB0aGlzLl9tZXNzYWdlc1t0aGlzLl9sb2NhbGVdID0gbWVzc2FnZXM7XG4gICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIpO1xuICB9XG4gIGFjdGl2YXRlKGxvY2FsZSwgbG9jYWxlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghdGhpcy5fbWVzc2FnZXNbbG9jYWxlXSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYE1lc3NhZ2VzIGZvciBsb2NhbGUgXCIke2xvY2FsZX1cIiBub3QgbG9hZGVkLmApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9sb2NhbGUgPSBsb2NhbGU7XG4gICAgdGhpcy5fbG9jYWxlcyA9IGxvY2FsZXM7XG4gICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIpO1xuICB9XG4gIF8oaWQsIHZhbHVlcywgb3B0aW9ucykge1xuICAgIGlmICghdGhpcy5sb2NhbGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJMaW5ndWk6IEF0dGVtcHRlZCB0byBjYWxsIGEgdHJhbnNsYXRpb24gZnVuY3Rpb24gd2l0aG91dCBzZXR0aW5nIGEgbG9jYWxlLlxcbk1ha2Ugc3VyZSB0byBjYWxsIGBpMThuLmFjdGl2YXRlKGxvY2FsZSlgIGJlZm9yZSB1c2luZyBMaW5ndWkgZnVuY3Rpb25zLlxcblRoaXMgaXNzdWUgbWF5IGFsc28gb2NjdXIgZHVlIHRvIGEgcmFjZSBjb25kaXRpb24gaW4geW91ciBpbml0aWFsaXphdGlvbiBsb2dpYy5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IG1lc3NhZ2UgPSBvcHRpb25zPy5tZXNzYWdlO1xuICAgIGlmICghaWQpIHtcbiAgICAgIGlkID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKCFpc1N0cmluZyhpZCkpIHtcbiAgICAgIHZhbHVlcyA9IGlkLnZhbHVlcyB8fCB2YWx1ZXM7XG4gICAgICBtZXNzYWdlID0gaWQubWVzc2FnZTtcbiAgICAgIGlkID0gaWQuaWQ7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VGb3JJZCA9IHRoaXMubWVzc2FnZXNbaWRdO1xuICAgIGNvbnN0IG1lc3NhZ2VNaXNzaW5nID0gbWVzc2FnZUZvcklkID09PSB2b2lkIDA7XG4gICAgY29uc3QgbWlzc2luZyA9IHRoaXMuX21pc3Npbmc7XG4gICAgaWYgKG1pc3NpbmcgJiYgbWVzc2FnZU1pc3NpbmcpIHtcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG1pc3NpbmcpID8gbWlzc2luZyh0aGlzLl9sb2NhbGUsIGlkKSA6IG1pc3Npbmc7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlTWlzc2luZykge1xuICAgICAgdGhpcy5lbWl0KFwibWlzc2luZ1wiLCB7IGlkLCBsb2NhbGU6IHRoaXMuX2xvY2FsZSB9KTtcbiAgICB9XG4gICAgbGV0IHRyYW5zbGF0aW9uID0gbWVzc2FnZUZvcklkIHx8IG1lc3NhZ2UgfHwgaWQ7XG4gICAgaWYgKGlzU3RyaW5nKHRyYW5zbGF0aW9uKSkge1xuICAgICAgaWYgKHRoaXMuX21lc3NhZ2VDb21waWxlcikge1xuICAgICAgICB0cmFuc2xhdGlvbiA9IHRoaXMuX21lc3NhZ2VDb21waWxlcih0cmFuc2xhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oYFVuY29tcGlsZWQgbWVzc2FnZSBkZXRlY3RlZCEgTWVzc2FnZTpcblxuPiAke3RyYW5zbGF0aW9ufVxuXG5UaGF0IG1lYW5zIHlvdSB1c2UgcmF3IGNhdGFsb2cgb3IgeW91ciBjYXRhbG9nIGRvZXNuJ3QgaGF2ZSBhIHRyYW5zbGF0aW9uIGZvciB0aGUgbWVzc2FnZSBhbmQgZmFsbGJhY2sgd2FzIHVzZWQuXG5JQ1UgZmVhdHVyZXMgc3VjaCBhcyBpbnRlcnBvbGF0aW9uIGFuZCBwbHVyYWxzIHdpbGwgbm90IHdvcmsgcHJvcGVybHkgZm9yIHRoYXQgbWVzc2FnZS4gXG5cblBsZWFzZSBjb21waWxlIHlvdXIgY2F0YWxvZyBmaXJzdC4gXG5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzU3RyaW5nKHRyYW5zbGF0aW9uKSAmJiBVTklDT0RFX1JFR0VYLnRlc3QodHJhbnNsYXRpb24pKVxuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoYFwiJHt0cmFuc2xhdGlvbn1cImApO1xuICAgIGlmIChpc1N0cmluZyh0cmFuc2xhdGlvbikpXG4gICAgICByZXR1cm4gdHJhbnNsYXRpb247XG4gICAgcmV0dXJuIGludGVycG9sYXRlKFxuICAgICAgdHJhbnNsYXRpb24sXG4gICAgICB0aGlzLl9sb2NhbGUsXG4gICAgICB0aGlzLl9sb2NhbGVzXG4gICAgKSh2YWx1ZXMsIG9wdGlvbnM/LmZvcm1hdHMpO1xuICB9XG4gIGRhdGUodmFsdWUsIGZvcm1hdCkge1xuICAgIHJldHVybiBkYXRlKHRoaXMuX2xvY2FsZXMgfHwgdGhpcy5fbG9jYWxlLCB2YWx1ZSwgZm9ybWF0KTtcbiAgfVxuICBudW1iZXIodmFsdWUsIGZvcm1hdCkge1xuICAgIHJldHVybiBudW1iZXIodGhpcy5fbG9jYWxlcyB8fCB0aGlzLl9sb2NhbGUsIHZhbHVlLCBmb3JtYXQpO1xuICB9XG59XG5mdW5jdGlvbiBzZXR1cEkxOG4ocGFyYW1zID0ge30pIHtcbiAgcmV0dXJuIG5ldyBJMThuKHBhcmFtcyk7XG59XG5cbmNvbnN0IGkxOG4gPSBzZXR1cEkxOG4oKTtcblxuZXhwb3J0IHsgSTE4biwgZm9ybWF0cywgaTE4biwgc2V0dXBJMThuIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@lingui+core@5.3.1_@lingui+babel-plugin-lingui-macro@5.3.1_babel-plugin-macros@3.1.0_ty_09fd4f3f9e842c9ce5faa9f163a4b1ad/node_modules/@lingui/core/dist/index.mjs\n");

/***/ })

};
;