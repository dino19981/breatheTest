"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@messageformat+parser@5.1.1";
exports.ids = ["vendor-chunks/@messageformat+parser@5.1.1"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@messageformat+parser@5.1.1/node_modules/@messageformat/parser/lib/lexer.js":
/*!************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@messageformat+parser@5.1.1/node_modules/@messageformat/parser/lib/lexer.js ***!
  \************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.lexer = exports.states = void 0;\nconst moo_1 = __importDefault(__webpack_require__(/*! moo */ \"(ssr)/../../node_modules/.pnpm/moo@0.5.2/node_modules/moo/moo.js\"));\nexports.states = {\n    body: {\n        doubleapos: { match: \"''\", value: () => \"'\" },\n        quoted: {\n            lineBreaks: true,\n            match: /'[{}#](?:[^']|'')*'(?!')/u,\n            value: src => src.slice(1, -1).replace(/''/g, \"'\")\n        },\n        argument: {\n            lineBreaks: true,\n            match: /\\{\\s*[^\\p{Pat_Syn}\\p{Pat_WS}]+\\s*/u,\n            push: 'arg',\n            value: src => src.substring(1).trim()\n        },\n        octothorpe: '#',\n        end: { match: '}', pop: 1 },\n        content: { lineBreaks: true, match: /[^][^{}#']*/u }\n    },\n    arg: {\n        select: {\n            lineBreaks: true,\n            match: /,\\s*(?:plural|select|selectordinal)\\s*,\\s*/u,\n            next: 'select',\n            value: src => src.split(',')[1].trim()\n        },\n        'func-args': {\n            lineBreaks: true,\n            match: /,\\s*[^\\p{Pat_Syn}\\p{Pat_WS}]+\\s*,/u,\n            next: 'body',\n            value: src => src.split(',')[1].trim()\n        },\n        'func-simple': {\n            lineBreaks: true,\n            match: /,\\s*[^\\p{Pat_Syn}\\p{Pat_WS}]+\\s*/u,\n            value: src => src.substring(1).trim()\n        },\n        end: { match: '}', pop: 1 }\n    },\n    select: {\n        offset: {\n            lineBreaks: true,\n            match: /\\s*offset\\s*:\\s*\\d+\\s*/u,\n            value: src => src.split(':')[1].trim()\n        },\n        case: {\n            lineBreaks: true,\n            match: /\\s*(?:=\\d+|[^\\p{Pat_Syn}\\p{Pat_WS}]+)\\s*\\{/u,\n            push: 'body',\n            value: src => src.substring(0, src.indexOf('{')).trim()\n        },\n        end: { match: /\\s*\\}/u, pop: 1 }\n    }\n};\nexports.lexer = moo_1.default.states(exports.states);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXNzYWdlZm9ybWF0K3BhcnNlckA1LjEuMS9ub2RlX21vZHVsZXMvQG1lc3NhZ2Vmb3JtYXQvcGFyc2VyL2xpYi9sZXhlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsR0FBRyxjQUFjO0FBQzlCLDhCQUE4QixtQkFBTyxDQUFDLDZFQUFLO0FBQzNDLGNBQWM7QUFDZDtBQUNBLHNCQUFzQiwrQkFBK0I7QUFDckQ7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0JBQXNCLFFBQVEsUUFBUSxHQUFHLE9BQU87QUFDaEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGVBQWUsU0FBUyxXQUFXO0FBQ25DLG1CQUFtQixpQ0FBaUM7QUFDcEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNkJBQTZCLFFBQVEsR0FBRyxPQUFPO0FBQy9DO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDZCQUE2QixRQUFRLEdBQUcsT0FBTztBQUMvQztBQUNBLFNBQVM7QUFDVCxlQUFlLFNBQVM7QUFDeEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9DQUFvQyxRQUFRLEdBQUcsT0FBTyxRQUFRO0FBQzlEO0FBQ0EseURBQXlEO0FBQ3pELFNBQVM7QUFDVCxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBLGFBQWEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcnRlbS5zdGVwYW5vdi9mcm9udGVuZC1tb25vL25vZGVfbW9kdWxlcy8ucG5wbS9AbWVzc2FnZWZvcm1hdCtwYXJzZXJANS4xLjEvbm9kZV9tb2R1bGVzL0BtZXNzYWdlZm9ybWF0L3BhcnNlci9saWIvbGV4ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmxleGVyID0gZXhwb3J0cy5zdGF0ZXMgPSB2b2lkIDA7XG5jb25zdCBtb29fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibW9vXCIpKTtcbmV4cG9ydHMuc3RhdGVzID0ge1xuICAgIGJvZHk6IHtcbiAgICAgICAgZG91YmxlYXBvczogeyBtYXRjaDogXCInJ1wiLCB2YWx1ZTogKCkgPT4gXCInXCIgfSxcbiAgICAgICAgcXVvdGVkOiB7XG4gICAgICAgICAgICBsaW5lQnJlYWtzOiB0cnVlLFxuICAgICAgICAgICAgbWF0Y2g6IC8nW3t9I10oPzpbXiddfCcnKSonKD8hJykvdSxcbiAgICAgICAgICAgIHZhbHVlOiBzcmMgPT4gc3JjLnNsaWNlKDEsIC0xKS5yZXBsYWNlKC8nJy9nLCBcIidcIilcbiAgICAgICAgfSxcbiAgICAgICAgYXJndW1lbnQ6IHtcbiAgICAgICAgICAgIGxpbmVCcmVha3M6IHRydWUsXG4gICAgICAgICAgICBtYXRjaDogL1xce1xccypbXlxccHtQYXRfU3lufVxccHtQYXRfV1N9XStcXHMqL3UsXG4gICAgICAgICAgICBwdXNoOiAnYXJnJyxcbiAgICAgICAgICAgIHZhbHVlOiBzcmMgPT4gc3JjLnN1YnN0cmluZygxKS50cmltKClcbiAgICAgICAgfSxcbiAgICAgICAgb2N0b3Rob3JwZTogJyMnLFxuICAgICAgICBlbmQ6IHsgbWF0Y2g6ICd9JywgcG9wOiAxIH0sXG4gICAgICAgIGNvbnRlbnQ6IHsgbGluZUJyZWFrczogdHJ1ZSwgbWF0Y2g6IC9bXl1bXnt9IyddKi91IH1cbiAgICB9LFxuICAgIGFyZzoge1xuICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICAgIGxpbmVCcmVha3M6IHRydWUsXG4gICAgICAgICAgICBtYXRjaDogLyxcXHMqKD86cGx1cmFsfHNlbGVjdHxzZWxlY3RvcmRpbmFsKVxccyosXFxzKi91LFxuICAgICAgICAgICAgbmV4dDogJ3NlbGVjdCcsXG4gICAgICAgICAgICB2YWx1ZTogc3JjID0+IHNyYy5zcGxpdCgnLCcpWzFdLnRyaW0oKVxuICAgICAgICB9LFxuICAgICAgICAnZnVuYy1hcmdzJzoge1xuICAgICAgICAgICAgbGluZUJyZWFrczogdHJ1ZSxcbiAgICAgICAgICAgIG1hdGNoOiAvLFxccypbXlxccHtQYXRfU3lufVxccHtQYXRfV1N9XStcXHMqLC91LFxuICAgICAgICAgICAgbmV4dDogJ2JvZHknLFxuICAgICAgICAgICAgdmFsdWU6IHNyYyA9PiBzcmMuc3BsaXQoJywnKVsxXS50cmltKClcbiAgICAgICAgfSxcbiAgICAgICAgJ2Z1bmMtc2ltcGxlJzoge1xuICAgICAgICAgICAgbGluZUJyZWFrczogdHJ1ZSxcbiAgICAgICAgICAgIG1hdGNoOiAvLFxccypbXlxccHtQYXRfU3lufVxccHtQYXRfV1N9XStcXHMqL3UsXG4gICAgICAgICAgICB2YWx1ZTogc3JjID0+IHNyYy5zdWJzdHJpbmcoMSkudHJpbSgpXG4gICAgICAgIH0sXG4gICAgICAgIGVuZDogeyBtYXRjaDogJ30nLCBwb3A6IDEgfVxuICAgIH0sXG4gICAgc2VsZWN0OiB7XG4gICAgICAgIG9mZnNldDoge1xuICAgICAgICAgICAgbGluZUJyZWFrczogdHJ1ZSxcbiAgICAgICAgICAgIG1hdGNoOiAvXFxzKm9mZnNldFxccyo6XFxzKlxcZCtcXHMqL3UsXG4gICAgICAgICAgICB2YWx1ZTogc3JjID0+IHNyYy5zcGxpdCgnOicpWzFdLnRyaW0oKVxuICAgICAgICB9LFxuICAgICAgICBjYXNlOiB7XG4gICAgICAgICAgICBsaW5lQnJlYWtzOiB0cnVlLFxuICAgICAgICAgICAgbWF0Y2g6IC9cXHMqKD86PVxcZCt8W15cXHB7UGF0X1N5bn1cXHB7UGF0X1dTfV0rKVxccypcXHsvdSxcbiAgICAgICAgICAgIHB1c2g6ICdib2R5JyxcbiAgICAgICAgICAgIHZhbHVlOiBzcmMgPT4gc3JjLnN1YnN0cmluZygwLCBzcmMuaW5kZXhPZigneycpKS50cmltKClcbiAgICAgICAgfSxcbiAgICAgICAgZW5kOiB7IG1hdGNoOiAvXFxzKlxcfS91LCBwb3A6IDEgfVxuICAgIH1cbn07XG5leHBvcnRzLmxleGVyID0gbW9vXzEuZGVmYXVsdC5zdGF0ZXMoZXhwb3J0cy5zdGF0ZXMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@messageformat+parser@5.1.1/node_modules/@messageformat/parser/lib/lexer.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@messageformat+parser@5.1.1/node_modules/@messageformat/parser/lib/parser.js":
/*!*************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@messageformat+parser@5.1.1/node_modules/@messageformat/parser/lib/parser.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * An AST parser for ICU MessageFormat strings\n *\n * @packageDocumentation\n * @example\n * ```\n * import { parse } from '@messageformat/parser\n *\n * parse('So {wow}.')\n * [ { type: 'content', value: 'So ' },\n *   { type: 'argument', arg: 'wow' },\n *   { type: 'content', value: '.' } ]\n *\n *\n * parse('Such { thing }. { count, selectordinal, one {First} two {Second}' +\n *       '                  few {Third} other {#th} } word.')\n * [ { type: 'content', value: 'Such ' },\n *   { type: 'argument', arg: 'thing' },\n *   { type: 'content', value: '. ' },\n *   { type: 'selectordinal',\n *     arg: 'count',\n *     cases: [\n *       { key: 'one', tokens: [ { type: 'content', value: 'First' } ] },\n *       { key: 'two', tokens: [ { type: 'content', value: 'Second' } ] },\n *       { key: 'few', tokens: [ { type: 'content', value: 'Third' } ] },\n *       { key: 'other',\n *         tokens: [ { type: 'octothorpe' }, { type: 'content', value: 'th' } ] }\n *     ] },\n *   { type: 'content', value: ' word.' } ]\n *\n *\n * parse('Many{type,select,plural{ numbers}selectordinal{ counting}' +\n *                          'select{ choices}other{ some {type}}}.')\n * [ { type: 'content', value: 'Many' },\n *   { type: 'select',\n *     arg: 'type',\n *     cases: [\n *       { key: 'plural', tokens: [ { type: 'content', value: 'numbers' } ] },\n *       { key: 'selectordinal', tokens: [ { type: 'content', value: 'counting' } ] },\n *       { key: 'select', tokens: [ { type: 'content', value: 'choices' } ] },\n *       { key: 'other',\n *         tokens: [ { type: 'content', value: 'some ' }, { type: 'argument', arg: 'type' } ] }\n *     ] },\n *   { type: 'content', value: '.' } ]\n *\n *\n * parse('{Such compliance')\n * // ParseError: invalid syntax at line 1 col 7:\n * //\n * //  {Such compliance\n * //        ^\n *\n *\n * const msg = '{words, plural, zero{No words} one{One word} other{# words}}'\n * parse(msg)\n * [ { type: 'plural',\n *     arg: 'words',\n *     cases: [\n *       { key: 'zero', tokens: [ { type: 'content', value: 'No words' } ] },\n *       { key: 'one', tokens: [ { type: 'content', value: 'One word' } ] },\n *       { key: 'other',\n *         tokens: [ { type: 'octothorpe' }, { type: 'content', value: ' words' } ] }\n *     ] } ]\n *\n *\n * parse(msg, { cardinal: [ 'one', 'other' ], ordinal: [ 'one', 'two', 'few', 'other' ] })\n * // ParseError: The plural case zero is not valid in this locale at line 1 col 17:\n * //\n * //   {words, plural, zero{\n * //                   ^\n * ```\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ParseError = void 0;\nexports.parse = parse;\nconst lexer_js_1 = __webpack_require__(/*! ./lexer.js */ \"(ssr)/../../node_modules/.pnpm/@messageformat+parser@5.1.1/node_modules/@messageformat/parser/lib/lexer.js\");\nconst getContext = (lt) => ({\n    offset: lt.offset,\n    line: lt.line,\n    col: lt.col,\n    text: lt.text,\n    lineBreaks: lt.lineBreaks\n});\nconst isSelectType = (type) => type === 'plural' || type === 'select' || type === 'selectordinal';\nfunction strictArgStyleParam(lt, param) {\n    let value = '';\n    let text = '';\n    for (const p of param) {\n        const pText = p.ctx.text;\n        text += pText;\n        switch (p.type) {\n            case 'content':\n                value += p.value;\n                break;\n            case 'argument':\n            case 'function':\n            case 'octothorpe':\n                value += pText;\n                break;\n            default:\n                throw new ParseError(lt, `Unsupported part in strict mode function arg style: ${pText}`);\n        }\n    }\n    const c = {\n        type: 'content',\n        value: value.trim(),\n        ctx: Object.assign({}, param[0].ctx, { text })\n    };\n    return [c];\n}\nconst strictArgTypes = [\n    'number',\n    'date',\n    'time',\n    'spellout',\n    'ordinal',\n    'duration'\n];\nconst defaultPluralKeys = ['zero', 'one', 'two', 'few', 'many', 'other'];\n/**\n * Thrown by {@link parse} on error\n *\n * @public\n */\nclass ParseError extends Error {\n    /** @internal */\n    constructor(lt, msg) {\n        super(lexer_js_1.lexer.formatError(lt, msg));\n    }\n}\nexports.ParseError = ParseError;\nclass Parser {\n    constructor(src, opt) {\n        var _a, _b, _c, _d;\n        this.lexer = lexer_js_1.lexer.reset(src);\n        this.cardinalKeys = (_a = opt === null || opt === void 0 ? void 0 : opt.cardinal) !== null && _a !== void 0 ? _a : defaultPluralKeys;\n        this.ordinalKeys = (_b = opt === null || opt === void 0 ? void 0 : opt.ordinal) !== null && _b !== void 0 ? _b : defaultPluralKeys;\n        this.strict = (_c = opt === null || opt === void 0 ? void 0 : opt.strict) !== null && _c !== void 0 ? _c : false;\n        this.strictPluralKeys = (_d = opt === null || opt === void 0 ? void 0 : opt.strictPluralKeys) !== null && _d !== void 0 ? _d : true;\n    }\n    parse() {\n        return this.parseBody(false, true);\n    }\n    checkSelectKey(lt, type, key) {\n        if (key[0] === '=') {\n            if (type === 'select') {\n                throw new ParseError(lt, `The case ${key} is not valid with select`);\n            }\n        }\n        else if (type !== 'select') {\n            const keys = type === 'plural' ? this.cardinalKeys : this.ordinalKeys;\n            if (this.strictPluralKeys && keys.length > 0 && !keys.includes(key)) {\n                const msg = `The ${type} case ${key} is not valid in this locale`;\n                throw new ParseError(lt, msg);\n            }\n        }\n    }\n    parseSelect({ value: arg }, inPlural, ctx, type) {\n        const sel = { type, arg, cases: [], ctx };\n        if (type === 'plural' || type === 'selectordinal')\n            inPlural = true;\n        else if (this.strict)\n            inPlural = false;\n        for (const lt of this.lexer) {\n            switch (lt.type) {\n                case 'offset':\n                    if (type === 'select') {\n                        throw new ParseError(lt, 'Unexpected plural offset for select');\n                    }\n                    if (sel.cases.length > 0) {\n                        throw new ParseError(lt, 'Plural offset must be set before cases');\n                    }\n                    sel.pluralOffset = Number(lt.value);\n                    ctx.text += lt.text;\n                    ctx.lineBreaks += lt.lineBreaks;\n                    break;\n                case 'case': {\n                    this.checkSelectKey(lt, type, lt.value);\n                    sel.cases.push({\n                        key: lt.value,\n                        tokens: this.parseBody(inPlural),\n                        ctx: getContext(lt)\n                    });\n                    break;\n                }\n                case 'end':\n                    return sel;\n                /* istanbul ignore next: never happens */\n                default:\n                    throw new ParseError(lt, `Unexpected lexer token: ${lt.type}`);\n            }\n        }\n        throw new ParseError(null, 'Unexpected message end');\n    }\n    parseArgToken(lt, inPlural) {\n        const ctx = getContext(lt);\n        const argType = this.lexer.next();\n        if (!argType)\n            throw new ParseError(null, 'Unexpected message end');\n        ctx.text += argType.text;\n        ctx.lineBreaks += argType.lineBreaks;\n        if (this.strict &&\n            (argType.type === 'func-simple' || argType.type === 'func-args') &&\n            !strictArgTypes.includes(argType.value)) {\n            const msg = `Invalid strict mode function arg type: ${argType.value}`;\n            throw new ParseError(lt, msg);\n        }\n        switch (argType.type) {\n            case 'end':\n                return { type: 'argument', arg: lt.value, ctx };\n            case 'func-simple': {\n                const end = this.lexer.next();\n                if (!end)\n                    throw new ParseError(null, 'Unexpected message end');\n                /* istanbul ignore if: never happens */\n                if (end.type !== 'end') {\n                    throw new ParseError(end, `Unexpected lexer token: ${end.type}`);\n                }\n                ctx.text += end.text;\n                if (isSelectType(argType.value.toLowerCase())) {\n                    throw new ParseError(argType, `Invalid type identifier: ${argType.value}`);\n                }\n                return {\n                    type: 'function',\n                    arg: lt.value,\n                    key: argType.value,\n                    ctx\n                };\n            }\n            case 'func-args': {\n                if (isSelectType(argType.value.toLowerCase())) {\n                    const msg = `Invalid type identifier: ${argType.value}`;\n                    throw new ParseError(argType, msg);\n                }\n                let param = this.parseBody(this.strict ? false : inPlural);\n                if (this.strict && param.length > 0) {\n                    param = strictArgStyleParam(lt, param);\n                }\n                return {\n                    type: 'function',\n                    arg: lt.value,\n                    key: argType.value,\n                    param,\n                    ctx\n                };\n            }\n            case 'select':\n                /* istanbul ignore else: never happens */\n                if (isSelectType(argType.value)) {\n                    return this.parseSelect(lt, inPlural, ctx, argType.value);\n                }\n                else {\n                    throw new ParseError(argType, `Unexpected select type ${argType.value}`);\n                }\n            /* istanbul ignore next: never happens */\n            default:\n                throw new ParseError(argType, `Unexpected lexer token: ${argType.type}`);\n        }\n    }\n    parseBody(inPlural, atRoot) {\n        const tokens = [];\n        let content = null;\n        for (const lt of this.lexer) {\n            if (lt.type === 'argument') {\n                if (content)\n                    content = null;\n                tokens.push(this.parseArgToken(lt, inPlural));\n            }\n            else if (lt.type === 'octothorpe' && inPlural) {\n                if (content)\n                    content = null;\n                tokens.push({ type: 'octothorpe', ctx: getContext(lt) });\n            }\n            else if (lt.type === 'end' && !atRoot) {\n                return tokens;\n            }\n            else {\n                let value = lt.value;\n                if (!inPlural && lt.type === 'quoted' && value[0] === '#') {\n                    if (value.includes('{')) {\n                        const errMsg = `Unsupported escape pattern: ${value}`;\n                        throw new ParseError(lt, errMsg);\n                    }\n                    value = lt.text;\n                }\n                if (content) {\n                    content.value += value;\n                    content.ctx.text += lt.text;\n                    content.ctx.lineBreaks += lt.lineBreaks;\n                }\n                else {\n                    content = { type: 'content', value, ctx: getContext(lt) };\n                    tokens.push(content);\n                }\n            }\n        }\n        if (atRoot)\n            return tokens;\n        throw new ParseError(null, 'Unexpected message end');\n    }\n}\n/**\n * Parse an input string into an array of tokens\n *\n * @public\n * @remarks\n * The parser only supports the default `DOUBLE_OPTIONAL`\n * {@link http://www.icu-project.org/apiref/icu4c/messagepattern_8h.html#af6e0757e0eb81c980b01ee5d68a9978b | apostrophe mode}.\n */\nfunction parse(src, options = {}) {\n    const parser = new Parser(src, options);\n    return parser.parse();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BtZXNzYWdlZm9ybWF0K3BhcnNlckA1LjEuMS9ub2RlX21vZHVsZXMvQG1lc3NhZ2Vmb3JtYXQvcGFyc2VyL2xpYi9wYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxjQUFjLElBQUk7QUFDbEIsT0FBTywrQkFBK0I7QUFDdEMsT0FBTyw4QkFBOEI7QUFDckMsT0FBTyw4QkFBOEI7QUFDckM7QUFDQTtBQUNBLGlCQUFpQixPQUFPLElBQUksMkJBQTJCLE9BQU8sS0FBSyxPQUFPO0FBQzFFLGlDQUFpQyxPQUFPLE9BQU8sT0FBTztBQUN0RCxPQUFPLGlDQUFpQztBQUN4QyxPQUFPLGdDQUFnQztBQUN2QyxPQUFPLDhCQUE4QjtBQUNyQyxPQUFPO0FBQ1A7QUFDQTtBQUNBLFdBQVcsd0JBQXdCLGtDQUFrQyxHQUFHO0FBQ3hFLFdBQVcsd0JBQXdCLG1DQUFtQyxHQUFHO0FBQ3pFLFdBQVcsd0JBQXdCLGtDQUFrQyxHQUFHO0FBQ3hFLFdBQVc7QUFDWCx1QkFBdUIsb0JBQW9CLElBQUksK0JBQStCO0FBQzlFLFVBQVU7QUFDVixPQUFPLG1DQUFtQztBQUMxQztBQUNBO0FBQ0EsZUFBZSxvQkFBb0IsUUFBUSxlQUFlLFNBQVM7QUFDbkUscUNBQXFDLFFBQVEsT0FBTyxNQUFNLE9BQU87QUFDakUsT0FBTyxnQ0FBZ0M7QUFDdkMsT0FBTztBQUNQO0FBQ0E7QUFDQSxXQUFXLDJCQUEyQixvQ0FBb0MsR0FBRztBQUM3RSxXQUFXLGtDQUFrQyxxQ0FBcUMsR0FBRztBQUNyRixXQUFXLDJCQUEyQixvQ0FBb0MsR0FBRztBQUM3RSxXQUFXO0FBQ1gsdUJBQXVCLGlDQUFpQyxJQUFJLGdDQUFnQztBQUM1RixVQUFVO0FBQ1YsT0FBTyw4QkFBOEI7QUFDckM7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtB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aEM7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXJ0ZW0uc3RlcGFub3YvZnJvbnRlbmQtbW9uby9ub2RlX21vZHVsZXMvLnBucG0vQG1lc3NhZ2Vmb3JtYXQrcGFyc2VyQDUuMS4xL25vZGVfbW9kdWxlcy9AbWVzc2FnZWZvcm1hdC9wYXJzZXIvbGliL3BhcnNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQW4gQVNUIHBhcnNlciBmb3IgSUNVIE1lc3NhZ2VGb3JtYXQgc3RyaW5nc1xuICpcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogaW1wb3J0IHsgcGFyc2UgfSBmcm9tICdAbWVzc2FnZWZvcm1hdC9wYXJzZXJcbiAqXG4gKiBwYXJzZSgnU28ge3dvd30uJylcbiAqIFsgeyB0eXBlOiAnY29udGVudCcsIHZhbHVlOiAnU28gJyB9LFxuICogICB7IHR5cGU6ICdhcmd1bWVudCcsIGFyZzogJ3dvdycgfSxcbiAqICAgeyB0eXBlOiAnY29udGVudCcsIHZhbHVlOiAnLicgfSBdXG4gKlxuICpcbiAqIHBhcnNlKCdTdWNoIHsgdGhpbmcgfS4geyBjb3VudCwgc2VsZWN0b3JkaW5hbCwgb25lIHtGaXJzdH0gdHdvIHtTZWNvbmR9JyArXG4gKiAgICAgICAnICAgICAgICAgICAgICAgICAgZmV3IHtUaGlyZH0gb3RoZXIgeyN0aH0gfSB3b3JkLicpXG4gKiBbIHsgdHlwZTogJ2NvbnRlbnQnLCB2YWx1ZTogJ1N1Y2ggJyB9LFxuICogICB7IHR5cGU6ICdhcmd1bWVudCcsIGFyZzogJ3RoaW5nJyB9LFxuICogICB7IHR5cGU6ICdjb250ZW50JywgdmFsdWU6ICcuICcgfSxcbiAqICAgeyB0eXBlOiAnc2VsZWN0b3JkaW5hbCcsXG4gKiAgICAgYXJnOiAnY291bnQnLFxuICogICAgIGNhc2VzOiBbXG4gKiAgICAgICB7IGtleTogJ29uZScsIHRva2VuczogWyB7IHR5cGU6ICdjb250ZW50JywgdmFsdWU6ICdGaXJzdCcgfSBdIH0sXG4gKiAgICAgICB7IGtleTogJ3R3bycsIHRva2VuczogWyB7IHR5cGU6ICdjb250ZW50JywgdmFsdWU6ICdTZWNvbmQnIH0gXSB9LFxuICogICAgICAgeyBrZXk6ICdmZXcnLCB0b2tlbnM6IFsgeyB0eXBlOiAnY29udGVudCcsIHZhbHVlOiAnVGhpcmQnIH0gXSB9LFxuICogICAgICAgeyBrZXk6ICdvdGhlcicsXG4gKiAgICAgICAgIHRva2VuczogWyB7IHR5cGU6ICdvY3RvdGhvcnBlJyB9LCB7IHR5cGU6ICdjb250ZW50JywgdmFsdWU6ICd0aCcgfSBdIH1cbiAqICAgICBdIH0sXG4gKiAgIHsgdHlwZTogJ2NvbnRlbnQnLCB2YWx1ZTogJyB3b3JkLicgfSBdXG4gKlxuICpcbiAqIHBhcnNlKCdNYW55e3R5cGUsc2VsZWN0LHBsdXJhbHsgbnVtYmVyc31zZWxlY3RvcmRpbmFseyBjb3VudGluZ30nICtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAnc2VsZWN0eyBjaG9pY2VzfW90aGVyeyBzb21lIHt0eXBlfX19LicpXG4gKiBbIHsgdHlwZTogJ2NvbnRlbnQnLCB2YWx1ZTogJ01hbnknIH0sXG4gKiAgIHsgdHlwZTogJ3NlbGVjdCcsXG4gKiAgICAgYXJnOiAndHlwZScsXG4gKiAgICAgY2FzZXM6IFtcbiAqICAgICAgIHsga2V5OiAncGx1cmFsJywgdG9rZW5zOiBbIHsgdHlwZTogJ2NvbnRlbnQnLCB2YWx1ZTogJ251bWJlcnMnIH0gXSB9LFxuICogICAgICAgeyBrZXk6ICdzZWxlY3RvcmRpbmFsJywgdG9rZW5zOiBbIHsgdHlwZTogJ2NvbnRlbnQnLCB2YWx1ZTogJ2NvdW50aW5nJyB9IF0gfSxcbiAqICAgICAgIHsga2V5OiAnc2VsZWN0JywgdG9rZW5zOiBbIHsgdHlwZTogJ2NvbnRlbnQnLCB2YWx1ZTogJ2Nob2ljZXMnIH0gXSB9LFxuICogICAgICAgeyBrZXk6ICdvdGhlcicsXG4gKiAgICAgICAgIHRva2VuczogWyB7IHR5cGU6ICdjb250ZW50JywgdmFsdWU6ICdzb21lICcgfSwgeyB0eXBlOiAnYXJndW1lbnQnLCBhcmc6ICd0eXBlJyB9IF0gfVxuICogICAgIF0gfSxcbiAqICAgeyB0eXBlOiAnY29udGVudCcsIHZhbHVlOiAnLicgfSBdXG4gKlxuICpcbiAqIHBhcnNlKCd7U3VjaCBjb21wbGlhbmNlJylcbiAqIC8vIFBhcnNlRXJyb3I6IGludmFsaWQgc3ludGF4IGF0IGxpbmUgMSBjb2wgNzpcbiAqIC8vXG4gKiAvLyAge1N1Y2ggY29tcGxpYW5jZVxuICogLy8gICAgICAgIF5cbiAqXG4gKlxuICogY29uc3QgbXNnID0gJ3t3b3JkcywgcGx1cmFsLCB6ZXJve05vIHdvcmRzfSBvbmV7T25lIHdvcmR9IG90aGVyeyMgd29yZHN9fSdcbiAqIHBhcnNlKG1zZylcbiAqIFsgeyB0eXBlOiAncGx1cmFsJyxcbiAqICAgICBhcmc6ICd3b3JkcycsXG4gKiAgICAgY2FzZXM6IFtcbiAqICAgICAgIHsga2V5OiAnemVybycsIHRva2VuczogWyB7IHR5cGU6ICdjb250ZW50JywgdmFsdWU6ICdObyB3b3JkcycgfSBdIH0sXG4gKiAgICAgICB7IGtleTogJ29uZScsIHRva2VuczogWyB7IHR5cGU6ICdjb250ZW50JywgdmFsdWU6ICdPbmUgd29yZCcgfSBdIH0sXG4gKiAgICAgICB7IGtleTogJ290aGVyJyxcbiAqICAgICAgICAgdG9rZW5zOiBbIHsgdHlwZTogJ29jdG90aG9ycGUnIH0sIHsgdHlwZTogJ2NvbnRlbnQnLCB2YWx1ZTogJyB3b3JkcycgfSBdIH1cbiAqICAgICBdIH0gXVxuICpcbiAqXG4gKiBwYXJzZShtc2csIHsgY2FyZGluYWw6IFsgJ29uZScsICdvdGhlcicgXSwgb3JkaW5hbDogWyAnb25lJywgJ3R3bycsICdmZXcnLCAnb3RoZXInIF0gfSlcbiAqIC8vIFBhcnNlRXJyb3I6IFRoZSBwbHVyYWwgY2FzZSB6ZXJvIGlzIG5vdCB2YWxpZCBpbiB0aGlzIGxvY2FsZSBhdCBsaW5lIDEgY29sIDE3OlxuICogLy9cbiAqIC8vICAge3dvcmRzLCBwbHVyYWwsIHplcm97XG4gKiAvLyAgICAgICAgICAgICAgICAgICBeXG4gKiBgYGBcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXJzZUVycm9yID0gdm9pZCAwO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuY29uc3QgbGV4ZXJfanNfMSA9IHJlcXVpcmUoXCIuL2xleGVyLmpzXCIpO1xuY29uc3QgZ2V0Q29udGV4dCA9IChsdCkgPT4gKHtcbiAgICBvZmZzZXQ6IGx0Lm9mZnNldCxcbiAgICBsaW5lOiBsdC5saW5lLFxuICAgIGNvbDogbHQuY29sLFxuICAgIHRleHQ6IGx0LnRleHQsXG4gICAgbGluZUJyZWFrczogbHQubGluZUJyZWFrc1xufSk7XG5jb25zdCBpc1NlbGVjdFR5cGUgPSAodHlwZSkgPT4gdHlwZSA9PT0gJ3BsdXJhbCcgfHwgdHlwZSA9PT0gJ3NlbGVjdCcgfHwgdHlwZSA9PT0gJ3NlbGVjdG9yZGluYWwnO1xuZnVuY3Rpb24gc3RyaWN0QXJnU3R5bGVQYXJhbShsdCwgcGFyYW0pIHtcbiAgICBsZXQgdmFsdWUgPSAnJztcbiAgICBsZXQgdGV4dCA9ICcnO1xuICAgIGZvciAoY29uc3QgcCBvZiBwYXJhbSkge1xuICAgICAgICBjb25zdCBwVGV4dCA9IHAuY3R4LnRleHQ7XG4gICAgICAgIHRleHQgKz0gcFRleHQ7XG4gICAgICAgIHN3aXRjaCAocC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdjb250ZW50JzpcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBwLnZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYXJndW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgY2FzZSAnb2N0b3Rob3JwZSc6XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gcFRleHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGx0LCBgVW5zdXBwb3J0ZWQgcGFydCBpbiBzdHJpY3QgbW9kZSBmdW5jdGlvbiBhcmcgc3R5bGU6ICR7cFRleHR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYyA9IHtcbiAgICAgICAgdHlwZTogJ2NvbnRlbnQnLFxuICAgICAgICB2YWx1ZTogdmFsdWUudHJpbSgpLFxuICAgICAgICBjdHg6IE9iamVjdC5hc3NpZ24oe30sIHBhcmFtWzBdLmN0eCwgeyB0ZXh0IH0pXG4gICAgfTtcbiAgICByZXR1cm4gW2NdO1xufVxuY29uc3Qgc3RyaWN0QXJnVHlwZXMgPSBbXG4gICAgJ251bWJlcicsXG4gICAgJ2RhdGUnLFxuICAgICd0aW1lJyxcbiAgICAnc3BlbGxvdXQnLFxuICAgICdvcmRpbmFsJyxcbiAgICAnZHVyYXRpb24nXG5dO1xuY29uc3QgZGVmYXVsdFBsdXJhbEtleXMgPSBbJ3plcm8nLCAnb25lJywgJ3R3bycsICdmZXcnLCAnbWFueScsICdvdGhlciddO1xuLyoqXG4gKiBUaHJvd24gYnkge0BsaW5rIHBhcnNlfSBvbiBlcnJvclxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgUGFyc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgY29uc3RydWN0b3IobHQsIG1zZykge1xuICAgICAgICBzdXBlcihsZXhlcl9qc18xLmxleGVyLmZvcm1hdEVycm9yKGx0LCBtc2cpKTtcbiAgICB9XG59XG5leHBvcnRzLlBhcnNlRXJyb3IgPSBQYXJzZUVycm9yO1xuY2xhc3MgUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcihzcmMsIG9wdCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIHRoaXMubGV4ZXIgPSBsZXhlcl9qc18xLmxleGVyLnJlc2V0KHNyYyk7XG4gICAgICAgIHRoaXMuY2FyZGluYWxLZXlzID0gKF9hID0gb3B0ID09PSBudWxsIHx8IG9wdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0LmNhcmRpbmFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkZWZhdWx0UGx1cmFsS2V5cztcbiAgICAgICAgdGhpcy5vcmRpbmFsS2V5cyA9IChfYiA9IG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5vcmRpbmFsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBkZWZhdWx0UGx1cmFsS2V5cztcbiAgICAgICAgdGhpcy5zdHJpY3QgPSAoX2MgPSBvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQuc3RyaWN0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5zdHJpY3RQbHVyYWxLZXlzID0gKF9kID0gb3B0ID09PSBudWxsIHx8IG9wdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0LnN0cmljdFBsdXJhbEtleXMpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHRydWU7XG4gICAgfVxuICAgIHBhcnNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJvZHkoZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgICBjaGVja1NlbGVjdEtleShsdCwgdHlwZSwga2V5KSB7XG4gICAgICAgIGlmIChrZXlbMF0gPT09ICc9Jykge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IobHQsIGBUaGUgY2FzZSAke2tleX0gaXMgbm90IHZhbGlkIHdpdGggc2VsZWN0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSB0eXBlID09PSAncGx1cmFsJyA/IHRoaXMuY2FyZGluYWxLZXlzIDogdGhpcy5vcmRpbmFsS2V5cztcbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmljdFBsdXJhbEtleXMgJiYga2V5cy5sZW5ndGggPiAwICYmICFrZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBgVGhlICR7dHlwZX0gY2FzZSAke2tleX0gaXMgbm90IHZhbGlkIGluIHRoaXMgbG9jYWxlYDtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihsdCwgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZVNlbGVjdCh7IHZhbHVlOiBhcmcgfSwgaW5QbHVyYWwsIGN0eCwgdHlwZSkge1xuICAgICAgICBjb25zdCBzZWwgPSB7IHR5cGUsIGFyZywgY2FzZXM6IFtdLCBjdHggfTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdwbHVyYWwnIHx8IHR5cGUgPT09ICdzZWxlY3RvcmRpbmFsJylcbiAgICAgICAgICAgIGluUGx1cmFsID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdHJpY3QpXG4gICAgICAgICAgICBpblBsdXJhbCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IGx0IG9mIHRoaXMubGV4ZXIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobHQudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ29mZnNldCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnc2VsZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IobHQsICdVbmV4cGVjdGVkIHBsdXJhbCBvZmZzZXQgZm9yIHNlbGVjdCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWwuY2FzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IobHQsICdQbHVyYWwgb2Zmc2V0IG11c3QgYmUgc2V0IGJlZm9yZSBjYXNlcycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbC5wbHVyYWxPZmZzZXQgPSBOdW1iZXIobHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBjdHgudGV4dCArPSBsdC50ZXh0O1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZUJyZWFrcyArPSBsdC5saW5lQnJlYWtzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjYXNlJzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrU2VsZWN0S2V5KGx0LCB0eXBlLCBsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbC5jYXNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogbHQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMucGFyc2VCb2R5KGluUGx1cmFsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eDogZ2V0Q29udGV4dChsdClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsO1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBuZXZlciBoYXBwZW5zICovXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IobHQsIGBVbmV4cGVjdGVkIGxleGVyIHRva2VuOiAke2x0LnR5cGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IobnVsbCwgJ1VuZXhwZWN0ZWQgbWVzc2FnZSBlbmQnKTtcbiAgICB9XG4gICAgcGFyc2VBcmdUb2tlbihsdCwgaW5QbHVyYWwpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gZ2V0Q29udGV4dChsdCk7XG4gICAgICAgIGNvbnN0IGFyZ1R5cGUgPSB0aGlzLmxleGVyLm5leHQoKTtcbiAgICAgICAgaWYgKCFhcmdUeXBlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IobnVsbCwgJ1VuZXhwZWN0ZWQgbWVzc2FnZSBlbmQnKTtcbiAgICAgICAgY3R4LnRleHQgKz0gYXJnVHlwZS50ZXh0O1xuICAgICAgICBjdHgubGluZUJyZWFrcyArPSBhcmdUeXBlLmxpbmVCcmVha3M7XG4gICAgICAgIGlmICh0aGlzLnN0cmljdCAmJlxuICAgICAgICAgICAgKGFyZ1R5cGUudHlwZSA9PT0gJ2Z1bmMtc2ltcGxlJyB8fCBhcmdUeXBlLnR5cGUgPT09ICdmdW5jLWFyZ3MnKSAmJlxuICAgICAgICAgICAgIXN0cmljdEFyZ1R5cGVzLmluY2x1ZGVzKGFyZ1R5cGUudmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBgSW52YWxpZCBzdHJpY3QgbW9kZSBmdW5jdGlvbiBhcmcgdHlwZTogJHthcmdUeXBlLnZhbHVlfWA7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihsdCwgbXNnKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGFyZ1R5cGUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnYXJndW1lbnQnLCBhcmc6IGx0LnZhbHVlLCBjdHggfTtcbiAgICAgICAgICAgIGNhc2UgJ2Z1bmMtc2ltcGxlJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IHRoaXMubGV4ZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmICghZW5kKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihudWxsLCAnVW5leHBlY3RlZCBtZXNzYWdlIGVuZCcpO1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogbmV2ZXIgaGFwcGVucyAqL1xuICAgICAgICAgICAgICAgIGlmIChlbmQudHlwZSAhPT0gJ2VuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoZW5kLCBgVW5leHBlY3RlZCBsZXhlciB0b2tlbjogJHtlbmQudHlwZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LnRleHQgKz0gZW5kLnRleHQ7XG4gICAgICAgICAgICAgICAgaWYgKGlzU2VsZWN0VHlwZShhcmdUeXBlLnZhbHVlLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGFyZ1R5cGUsIGBJbnZhbGlkIHR5cGUgaWRlbnRpZmllcjogJHthcmdUeXBlLnZhbHVlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICBhcmc6IGx0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGFyZ1R5cGUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGN0eFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdmdW5jLWFyZ3MnOiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU2VsZWN0VHlwZShhcmdUeXBlLnZhbHVlLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBJbnZhbGlkIHR5cGUgaWRlbnRpZmllcjogJHthcmdUeXBlLnZhbHVlfWA7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGFyZ1R5cGUsIG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBwYXJhbSA9IHRoaXMucGFyc2VCb2R5KHRoaXMuc3RyaWN0ID8gZmFsc2UgOiBpblBsdXJhbCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RyaWN0ICYmIHBhcmFtLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0gPSBzdHJpY3RBcmdTdHlsZVBhcmFtKGx0LCBwYXJhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGFyZzogbHQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGtleTogYXJnVHlwZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0sXG4gICAgICAgICAgICAgICAgICAgIGN0eFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBuZXZlciBoYXBwZW5zICovXG4gICAgICAgICAgICAgICAgaWYgKGlzU2VsZWN0VHlwZShhcmdUeXBlLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNlbGVjdChsdCwgaW5QbHVyYWwsIGN0eCwgYXJnVHlwZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihhcmdUeXBlLCBgVW5leHBlY3RlZCBzZWxlY3QgdHlwZSAke2FyZ1R5cGUudmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IG5ldmVyIGhhcHBlbnMgKi9cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYXJnVHlwZSwgYFVuZXhwZWN0ZWQgbGV4ZXIgdG9rZW46ICR7YXJnVHlwZS50eXBlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlQm9keShpblBsdXJhbCwgYXRSb290KSB7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgICAgICBsZXQgY29udGVudCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgbHQgb2YgdGhpcy5sZXhlcikge1xuICAgICAgICAgICAgaWYgKGx0LnR5cGUgPT09ICdhcmd1bWVudCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudClcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godGhpcy5wYXJzZUFyZ1Rva2VuKGx0LCBpblBsdXJhbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobHQudHlwZSA9PT0gJ29jdG90aG9ycGUnICYmIGluUGx1cmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogJ29jdG90aG9ycGUnLCBjdHg6IGdldENvbnRleHQobHQpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobHQudHlwZSA9PT0gJ2VuZCcgJiYgIWF0Um9vdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWluUGx1cmFsICYmIGx0LnR5cGUgPT09ICdxdW90ZWQnICYmIHZhbHVlWzBdID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKCd7JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9IGBVbnN1cHBvcnRlZCBlc2NhcGUgcGF0dGVybjogJHt2YWx1ZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IobHQsIGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsdC50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50LnZhbHVlICs9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50LmN0eC50ZXh0ICs9IGx0LnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuY3R4LmxpbmVCcmVha3MgKz0gbHQubGluZUJyZWFrcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB7IHR5cGU6ICdjb250ZW50JywgdmFsdWUsIGN0eDogZ2V0Q29udGV4dChsdCkgfTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goY29udGVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhdFJvb3QpXG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihudWxsLCAnVW5leHBlY3RlZCBtZXNzYWdlIGVuZCcpO1xuICAgIH1cbn1cbi8qKlxuICogUGFyc2UgYW4gaW5wdXQgc3RyaW5nIGludG8gYW4gYXJyYXkgb2YgdG9rZW5zXG4gKlxuICogQHB1YmxpY1xuICogQHJlbWFya3NcbiAqIFRoZSBwYXJzZXIgb25seSBzdXBwb3J0cyB0aGUgZGVmYXVsdCBgRE9VQkxFX09QVElPTkFMYFxuICoge0BsaW5rIGh0dHA6Ly93d3cuaWN1LXByb2plY3Qub3JnL2FwaXJlZi9pY3U0Yy9tZXNzYWdlcGF0dGVybl84aC5odG1sI2FmNmUwNzU3ZTBlYjgxYzk4MGIwMWVlNWQ2OGE5OTc4YiB8IGFwb3N0cm9waGUgbW9kZX0uXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKHNyYywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcGFyc2VyID0gbmV3IFBhcnNlcihzcmMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBwYXJzZXIucGFyc2UoKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@messageformat+parser@5.1.1/node_modules/@messageformat/parser/lib/parser.js\n");

/***/ })

};
;