// This file is auto-generated by @hey-api/openapi-ts

/**
 * Achievement data
 */
export type AchievementV1 = {
  /**
   * Unique identifier for the achievement
   */
  readonly id: string;
  /**
   * Name of the achievement
   */
  readonly name: string;
  /**
   * Detailed description of the achievement
   */
  readonly description: string;
  /**
   * Link to the achievement's icon
   */
  readonly iconLink: string;
};

/**
 * Page of achievements
 */
export type AchievementPageV1Readable = PageV1 & {
  content: Array<AchievementV1>;
};

/**
 * Page of achievements
 */
export type AchievementPageV1Writable = PageV1 & {
  content: Array<AchievementV1>;
};

/**
 * A summary of the AI analysis of the session
 */
export type AiSummaryV1 = {
  rating: number;
};

/**
 * Supported currencies for pricing
 */
export type CurrencyV1 =
  | "USD"
  | "EUR"
  | "GBP"
  | "JPY"
  | "AUD"
  | "CAD"
  | "CHF"
  | "SEK"
  | "DKK"
  | "NOK"
  | "NZD"
  | "RUB"
  | "SGD";

/**
 * Represents a document such as privacy policy or terms of service
 */
export type DocumentV1 = {
  /**
   * Unique identifier for the document
   */
  readonly id: string;
  /**
   * Title of the document
   */
  readonly title: string;
  /**
   * Link to the document content
   */
  readonly contentLink: string;
  /**
   * Version of the document
   */
  readonly version: string;
  /**
   * Timestamp when the document was created
   */
  readonly createdAt: string;
  locale: LocaleV1;
};

/**
 * Page of documents
 */
export type DocumentPageV1Readable = PageV1 & {
  content: Array<DocumentV1>;
};

/**
 * Page of documents
 */
export type DocumentPageV1Writable = PageV1 & {
  content: Array<DocumentV1>;
};

/**
 * Supported locales for documents
 */
export type LocaleV1 =
  | "en-US"
  | "fr-FR"
  | "es-ES"
  | "de-DE"
  | "da-DK"
  | "it-IT"
  | "ja-JP"
  | "zh-CN"
  | "ru-RU";

/**
 * Page metadata
 */
export type PageV1 = {
  number: number;
  size: number;
  totalPages: number;
  totalElements: number;
  first: boolean;
  last: boolean;
};

/**
 * Represents a subscription premium available in the app
 */
export type PremiumV1Readable = {
  /**
   * Unique identifier for the premium
   */
  readonly id: string;
  /**
   * Name of the premium subscription
   */
  readonly name: string;
  /**
   * Detailed description of the premium subscription
   */
  readonly description: string;
  /**
   * Type of the premium (e.g., monthly, yearly)
   */
  type: "monthly" | "yearly" | "lifetime";
  /**
   * List of prices for the premium subscription in different currencies
   */
  readonly prices: Array<PriceV1>;
  /**
   * Timestamp when the premium was created
   */
  readonly createdAt?: string;
};

/**
 * Represents a subscription premium available in the app
 */
export type PremiumV1Writable = {
  /**
   * Type of the premium (e.g., monthly, yearly)
   */
  type: "monthly" | "yearly" | "lifetime";
};

/**
 * Page of premium subscriptions
 */
export type PremiumPageV1Readable = PageV1 & {
  content: Array<PremiumV1Readable>;
};

/**
 * Page of premium subscriptions
 */
export type PremiumPageV1Writable = PageV1 & {
  content: Array<PremiumV1Writable>;
};

/**
 * Represents a price for a premium subscription in a specific currency
 */
export type PriceV1 = {
  currency: CurrencyV1;
  /**
   * Price amount in the specified currency
   */
  amount: number;
};

/**
 * A Problem Details object (RFC 9457)
 */
export type ProblemDetailV1 = {
  /**
   * A short, human-readable summary of the problem type.
   * It SHOULD NOT change from occurrence to occurrence of the problem
   *
   */
  title: string;
  /**
   * The HTTP status code generated by the origin server for this occurrence of the problem.
   */
  status: number;
  /**
   * A human-readable explanation specific to this occurrence of the problem.
   */
  detail: string;
  /**
   * A URI reference that identifies the specific occurrence of the problem.
   */
  instance: string;
  /**
   * Trace ID generated by the service in OpenTelemetry format
   */
  traceId: string;
  /**
   * A URI reference RFC3986 that identifies the problem type. This specification encourages that,
   * when dereferenced, it provide human-readable documentation for the problem type
   * (e.g., using HTML [W3C.REC-html5-20141028]). When type cannot be presented as URI, its value should
   * be "about:blank".
   *
   */
  type: string;
  /**
   * Additional unstructured data that can be filled in by the service
   */
  additionalProperties?: {
    [key: string]: unknown;
  };
};

/**
 * Generic reward data
 */
export type RewardV1 = {
  /**
   * Unique identifier for the reward
   */
  readonly id: string;
  type: RewardTypeV1;
  /**
   * Name of the reward
   */
  readonly name: string;
  /**
   * Detailed description of the reward
   */
  readonly description?: string;
  /**
   * Value or amount associated with the reward
   */
  readonly value: number;
  /**
   * Link to the reward's icon
   */
  readonly iconLink?: string;
};

/**
 * Types of rewards available in the app
 */
export type RewardTypeV1 = "coins";

/**
 * Detailed data of a breathing session
 */
export type SessionDataV1 = {
  inhalesCount: number;
  exhalesCount: number;
  holdCount: number;
  inhalesTotalSeconds: number;
  exhalesTotalSeconds: number;
  holdTotalSeconds: number;
  maxInhaleLengthSeconds: number;
  maxExhaleLengthSeconds: number;
  maxHoldLengthSeconds: number;
};

/**
 * Page of breathing sessions
 */
export type SessionPageV1Readable = PageV1 & {
  content: Array<SessionV1Readable>;
};

/**
 * Page of breathing sessions
 */
export type SessionPageV1Writable = PageV1 & {
  content: Array<SessionV1Writable>;
};

/**
 * Breathing session result
 */
export type SessionV1Readable = {
  /**
   * Unique identifier for the session
   */
  readonly id?: string;
  readonly userId: string;
  protocolName: string;
  durationSeconds: number;
  /**
   * Session start time
   */
  startTime: string;
  /**
   * Session end time
   */
  endTime: string;
  aiSummary: AiSummaryV1;
  data: SessionDataV1;
  readonly rewards?: Array<RewardV1>;
  /**
   * Link to the bucket with raw session data
   */
  dataStreamLink: string;
};

/**
 * Breathing session result
 */
export type SessionV1Writable = {
  protocolName: string;
  durationSeconds: number;
  /**
   * Session start time
   */
  startTime: string;
  /**
   * Session end time
   */
  endTime: string;
  aiSummary: AiSummaryV1;
  data: SessionDataV1;
  /**
   * Link to the bucket with raw session data
   */
  dataStreamLink: string;
};

/**
 * Tracks which achievements a user has unlocked and when
 */
export type UserAchievementV1 = {
  /**
   * Unique identifier of the user
   */
  readonly userId: string;
  /**
   * Unique identifier of the achievement
   */
  readonly achievementId: string;
  /**
   * Timestamp when the user unlocked the achievement
   */
  readonly unlockedAt: string;
};

/**
 * Page of user achievements
 */
export type UserAchievementPageV1Readable = PageV1 & {
  content: Array<UserAchievementV1>;
};

/**
 * Page of user achievements
 */
export type UserAchievementPageV1Writable = PageV1 & {
  content: Array<UserAchievementV1>;
};

/**
 * Best results of the user
 */
export type UserPersonalBestResultsV1 = {
  /**
   * Unique identifier of the user
   */
  readonly userId: string;
  /**
   * Maximum length of exhale in seconds
   */
  readonly maxExhaleLengthSeconds: number;
  /**
   * Maximum length of hold in seconds
   */
  readonly maxHoldLengthSeconds: number;
  /**
   * Maximum streak days
   */
  readonly maxStreakDays: number;
  /**
   * Current streak days
   */
  readonly currentStreakDays: number;
};

/**
 * Tracks the premium subscription a user has purchased and its details
 */
export type UserPremiumV1Readable = {
  /**
   * Unique identifier of the user
   */
  readonly userId: string;
  /**
   * Unique identifier of the premium subscription
   */
  readonly premiumId: string;
  /**
   * Timestamp when the premium subscription was activated
   */
  readonly activatedAt: string;
  /**
   * Timestamp when the premium subscription expires
   */
  readonly expiresAt?: string;
  /**
   * Status of the premium subscription (e.g., active, expired, canceled)
   */
  status: "active" | "expired" | "canceled";
  /**
   * Payment method used for the subscription (e.g., credit card, PayPal)
   */
  readonly paymentMethod?: string;
  /**
   * Unique identifier of the transaction for the purchase
   */
  readonly transactionId?: string;
  /**
   * Indicates if the subscription is set to auto-renew
   */
  autoRenew?: boolean;
};

/**
 * Tracks the premium subscription a user has purchased and its details
 */
export type UserPremiumV1Writable = {
  /**
   * Status of the premium subscription (e.g., active, expired, canceled)
   */
  status: "active" | "expired" | "canceled";
  /**
   * Indicates if the subscription is set to auto-renew
   */
  autoRenew?: boolean;
};

/**
 * Page of user premium subscriptions
 */
export type UserPremiumPageV1Readable = PageV1 & {
  content: Array<UserPremiumV1Readable>;
};

/**
 * Page of user premium subscriptions
 */
export type UserPremiumPageV1Writable = PageV1 & {
  content: Array<UserPremiumV1Writable>;
};

/**
 * User profile data
 */
export type UserProfileV1Readable = {
  /**
   * Unique identifier of the user
   */
  readonly userId?: string;
  /**
   * Username of the user
   */
  username: string;
  /**
   * Email address of the user
   */
  email?: string;
};

/**
 * User profile data
 */
export type UserProfileV1Writable = {
  /**
   * Username of the user
   */
  username: string;
  /**
   * Email address of the user
   */
  email?: string;
};

/**
 * Tracks which version of a document a user has signed and when
 */
export type UserSignedDocumentV1Readable = {
  /**
   * Unique identifier of the user
   */
  readonly userId?: string;
  /**
   * Unique identifier of the document
   */
  documentId: string;
  /**
   * Version of the document the user signed
   */
  signedVersion: string;
  /**
   * Timestamp when the user signed the document
   */
  readonly signedAt: string;
};

/**
 * Tracks which version of a document a user has signed and when
 */
export type UserSignedDocumentV1Writable = {
  /**
   * Unique identifier of the document
   */
  documentId: string;
  /**
   * Version of the document the user signed
   */
  signedVersion: string;
};

/**
 * Page of signed documents
 */
export type UserSignedDocumentPageV1Readable = PageV1 & {
  content: Array<UserSignedDocumentV1Readable>;
};

/**
 * Page of signed documents
 */
export type UserSignedDocumentPageV1Writable = PageV1 & {
  content: Array<UserSignedDocumentV1Writable>;
};

/**
 * Unique identifier of the user
 */
export type UserId = string;

/**
 * Page number
 */
export type Page = number;

/**
 * Page size
 */
export type Size = number;

export type GetHealthV1Data = {
  body?: never;
  path?: never;
  query?: never;
  url: "/health/v1";
};

export type GetHealthV1Errors = {
  /**
   * The API is unavailable
   */
  503: {
    [key: string]: unknown;
  };
};

export type GetHealthV1Error = GetHealthV1Errors[keyof GetHealthV1Errors];

export type GetHealthV1Responses = {
  /**
   * The API is healthy
   */
  200: {
    [key: string]: unknown;
  };
};

export type GetHealthV1Response =
  GetHealthV1Responses[keyof GetHealthV1Responses];

export type GetAchievementsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Page number
     */
    page?: number;
    /**
     * Page size
     */
    size?: number;
  };
  url: "/metadata/v1/achievements";
};

export type GetAchievementsErrors = {
  /**
   * Unauthorized
   */
  401: ProblemDetailV1;
  /**
   * Forbidden
   */
  403: ProblemDetailV1;
};

export type GetAchievementsError =
  GetAchievementsErrors[keyof GetAchievementsErrors];

export type GetAchievementsResponses = {
  /**
   * List of achievements
   */
  200: AchievementPageV1Readable;
};

export type GetAchievementsResponse =
  GetAchievementsResponses[keyof GetAchievementsResponses];

export type GetDocumentsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Page number
     */
    page?: number;
    /**
     * Page size
     */
    size?: number;
  };
  url: "/metadata/v1/documents";
};

export type GetDocumentsErrors = {
  /**
   * Unauthorized
   */
  401: ProblemDetailV1;
  /**
   * Forbidden
   */
  403: ProblemDetailV1;
};

export type GetDocumentsError = GetDocumentsErrors[keyof GetDocumentsErrors];

export type GetDocumentsResponses = {
  /**
   * List of documents
   */
  200: DocumentPageV1Readable;
};

export type GetDocumentsResponse =
  GetDocumentsResponses[keyof GetDocumentsResponses];

export type GetPremiumsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Page number
     */
    page?: number;
    /**
     * Page size
     */
    size?: number;
  };
  url: "/metadata/v1/premiums";
};

export type GetPremiumsErrors = {
  /**
   * Unauthorized
   */
  401: ProblemDetailV1;
  /**
   * Forbidden
   */
  403: ProblemDetailV1;
};

export type GetPremiumsError = GetPremiumsErrors[keyof GetPremiumsErrors];

export type GetPremiumsResponses = {
  /**
   * List of premiums
   */
  200: PremiumPageV1Readable;
};

export type GetPremiumsResponse =
  GetPremiumsResponses[keyof GetPremiumsResponses];

export type CreateUserProfileData = {
  /**
   * User profile data to create
   */
  body: UserProfileV1Writable;
  path?: never;
  query?: never;
  url: "/users/v1";
};

export type CreateUserProfileErrors = {
  /**
   * Bad request
   */
  400: ProblemDetailV1;
  /**
   * Unauthorized
   */
  401: ProblemDetailV1;
  /**
   * Forbidden
   */
  403: ProblemDetailV1;
  /**
   * Unprocessable Entity
   */
  422: ProblemDetailV1;
};

export type CreateUserProfileError =
  CreateUserProfileErrors[keyof CreateUserProfileErrors];

export type CreateUserProfileResponses = {
  /**
   * User profile created successfully
   */
  201: UserProfileV1Readable;
};

export type CreateUserProfileResponse =
  CreateUserProfileResponses[keyof CreateUserProfileResponses];

export type DeleteUserProfileData = {
  body?: never;
  path: {
    /**
     * Unique identifier of the user
     */
    userId: string;
  };
  query?: never;
  url: "/users/v1/{userId}";
};

export type DeleteUserProfileErrors = {
  /**
   * Unauthorized
   */
  401: ProblemDetailV1;
  /**
   * Forbidden
   */
  403: ProblemDetailV1;
  /**
   * Not found
   */
  404: ProblemDetailV1;
};

export type DeleteUserProfileError =
  DeleteUserProfileErrors[keyof DeleteUserProfileErrors];

export type DeleteUserProfileResponses = {
  /**
   * User profile deleted successfully
   */
  204: void;
};

export type DeleteUserProfileResponse =
  DeleteUserProfileResponses[keyof DeleteUserProfileResponses];

export type GetUserProfileData = {
  body?: never;
  path: {
    /**
     * Unique identifier of the user
     */
    userId: string;
  };
  query?: never;
  url: "/users/v1/{userId}";
};

export type GetUserProfileErrors = {
  /**
   * Unauthorized
   */
  401: ProblemDetailV1;
  /**
   * Forbidden
   */
  403: ProblemDetailV1;
  /**
   * Not found
   */
  404: ProblemDetailV1;
};

export type GetUserProfileError =
  GetUserProfileErrors[keyof GetUserProfileErrors];

export type GetUserProfileResponses = {
  /**
   * Full profile data
   */
  200: UserProfileV1Readable;
};

export type GetUserProfileResponse =
  GetUserProfileResponses[keyof GetUserProfileResponses];

export type PatchUserProfileData = {
  /**
   * User profile data to update
   */
  body: {
    name?: string;
  };
  path: {
    /**
     * Unique identifier of the user
     */
    userId: string;
  };
  query?: never;
  url: "/users/v1/{userId}";
};

export type PatchUserProfileErrors = {
  /**
   * Bad request
   */
  400: ProblemDetailV1;
  /**
   * Unauthorized
   */
  401: ProblemDetailV1;
  /**
   * Forbidden
   */
  403: ProblemDetailV1;
  /**
   * Unprocessable Entity
   */
  422: ProblemDetailV1;
};

export type PatchUserProfileError =
  PatchUserProfileErrors[keyof PatchUserProfileErrors];

export type PatchUserProfileResponses = {
  /**
   * Updated user profile
   */
  200: UserProfileV1Readable;
};

export type PatchUserProfileResponse =
  PatchUserProfileResponses[keyof PatchUserProfileResponses];

export type ResetUserProgressData = {
  body?: never;
  path: {
    /**
     * Unique identifier of the user
     */
    userId: string;
  };
  query?: never;
  url: "/users/v1/{userId}/progress";
};

export type ResetUserProgressErrors = {
  /**
   * Unauthorized
   */
  401: ProblemDetailV1;
  /**
   * Forbidden
   */
  403: ProblemDetailV1;
  /**
   * Not found
   */
  404: ProblemDetailV1;
};

export type ResetUserProgressError =
  ResetUserProgressErrors[keyof ResetUserProgressErrors];

export type ResetUserProgressResponses = {
  /**
   * Progress reset successfully
   */
  204: void;
};

export type ResetUserProgressResponse =
  ResetUserProgressResponses[keyof ResetUserProgressResponses];

export type GetUserAchievementsData = {
  body?: never;
  path: {
    /**
     * Unique identifier of the user
     */
    userId: string;
  };
  query?: {
    /**
     * Page number
     */
    page?: number;
    /**
     * Page size
     */
    size?: number;
  };
  url: "/users/v1/{userId}/progress/achievements";
};

export type GetUserAchievementsErrors = {
  /**
   * Unauthorized
   */
  401: ProblemDetailV1;
  /**
   * Forbidden
   */
  403: ProblemDetailV1;
};

export type GetUserAchievementsError =
  GetUserAchievementsErrors[keyof GetUserAchievementsErrors];

export type GetUserAchievementsResponses = {
  /**
   * List of user achievements
   */
  200: UserAchievementPageV1Readable;
};

export type GetUserAchievementsResponse =
  GetUserAchievementsResponses[keyof GetUserAchievementsResponses];

export type GetUserPersonalBestResultsData = {
  body?: never;
  path: {
    /**
     * Unique identifier of the user
     */
    userId: string;
  };
  query?: never;
  url: "/users/v1/{userId}/progress/personal-best-results";
};

export type GetUserPersonalBestResultsErrors = {
  /**
   * Unauthorized
   */
  401: ProblemDetailV1;
  /**
   * Forbidden
   */
  403: ProblemDetailV1;
};

export type GetUserPersonalBestResultsError =
  GetUserPersonalBestResultsErrors[keyof GetUserPersonalBestResultsErrors];

export type GetUserPersonalBestResultsResponses = {
  /**
   * User best results
   */
  200: UserPersonalBestResultsV1;
};

export type GetUserPersonalBestResultsResponse =
  GetUserPersonalBestResultsResponses[keyof GetUserPersonalBestResultsResponses];

export type GetUserPremiumsData = {
  body?: never;
  path: {
    /**
     * Unique identifier of the user
     */
    userId: string;
  };
  query?: {
    /**
     * Page number
     */
    page?: number;
    /**
     * Page size
     */
    size?: number;
  };
  url: "/users/v1/{userId}/premiums";
};

export type GetUserPremiumsErrors = {
  /**
   * Unauthorized
   */
  401: ProblemDetailV1;
  /**
   * Forbidden
   */
  403: ProblemDetailV1;
};

export type GetUserPremiumsError =
  GetUserPremiumsErrors[keyof GetUserPremiumsErrors];

export type GetUserPremiumsResponses = {
  /**
   * List of user-specific premiums
   */
  200: UserPremiumPageV1Readable;
};

export type GetUserPremiumsResponse =
  GetUserPremiumsResponses[keyof GetUserPremiumsResponses];

export type GetSessionsData = {
  body?: never;
  path: {
    /**
     * Unique identifier of the user
     */
    userId: string;
  };
  query?: {
    /**
     * Page number
     */
    page?: number;
    /**
     * Page size
     */
    size?: number;
  };
  url: "/users/v1/{userId}/sessions";
};

export type GetSessionsErrors = {
  /**
   * Unauthorized
   */
  401: ProblemDetailV1;
  /**
   * Forbidden
   */
  403: ProblemDetailV1;
};

export type GetSessionsError = GetSessionsErrors[keyof GetSessionsErrors];

export type GetSessionsResponses = {
  /**
   * List of breathing sessions
   */
  200: SessionPageV1Readable;
};

export type GetSessionsResponse =
  GetSessionsResponses[keyof GetSessionsResponses];

export type PostSessionData = {
  /**
   * Session data to upload
   */
  body: SessionV1Writable;
  path: {
    /**
     * Unique identifier of the user
     */
    userId: string;
  };
  query?: never;
  url: "/users/v1/{userId}/sessions";
};

export type PostSessionErrors = {
  /**
   * Bad request
   */
  400: ProblemDetailV1;
  /**
   * Unauthorized
   */
  401: ProblemDetailV1;
  /**
   * Forbidden
   */
  403: ProblemDetailV1;
  /**
   * Unprocessable Entity
   */
  422: ProblemDetailV1;
};

export type PostSessionError = PostSessionErrors[keyof PostSessionErrors];

export type PostSessionResponses = {
  /**
   * Session result uploaded
   */
  201: unknown;
};

export type GetSignedDocumentsData = {
  body?: never;
  path: {
    /**
     * Unique identifier of the user
     */
    userId: string;
  };
  query?: {
    /**
     * Page number
     */
    page?: number;
    /**
     * Page size
     */
    size?: number;
  };
  url: "/users/v1/{userId}/signed-documents";
};

export type GetSignedDocumentsErrors = {
  /**
   * Unauthorized
   */
  401: ProblemDetailV1;
  /**
   * Forbidden
   */
  403: ProblemDetailV1;
};

export type GetSignedDocumentsError =
  GetSignedDocumentsErrors[keyof GetSignedDocumentsErrors];

export type GetSignedDocumentsResponses = {
  /**
   * List of signed documents
   */
  200: UserSignedDocumentPageV1Readable;
};

export type GetSignedDocumentsResponse =
  GetSignedDocumentsResponses[keyof GetSignedDocumentsResponses];

export type ClientOptions = {
  baseUrl: `${string}://${string}/api` | (string & {});
};
